'use strict';

/**
 * Get an accurate type check for the given Object.
 *
 * @param {Mixed} obj The object that needs to be detected.
 * @returns {String} The object type.
 * @api public
 */
function is(obj) {
  return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();
}

/**
 * Generate a custom options setter and getter.
 *
 * @param {String} name Name of the module using these options.
 * @param {Object} spec Options specification.
 * @returns {Function} Options constructor.
 * @api public
 */
module.exports = function generate(name, spec) {
  /**
   * Options parser because of reasons I just felt like writing this.
   *
   * @constructor
   * @param {Object} .. User supplied options.
   * @api private
   */
  function Options() {
    var options = this;

    this.data = Object.create(null);

    Array.prototype.slice.call(arguments).forEach(function each(opts) {
      if ('object' !== is(opts)) return;

      Object.keys(opts).forEach(function add(key) {
        options[key] = opts[key];
      });
    });
  }

  //
  // Use fusing to add the `readable`, `get` and `set` syntax sugar.
  //
  require('fusing')(Options);

  /**
   * Are we creating a secure server.
   *
   * @type {Boolean}
   * @public
   */
  Options.get('secure', function secure() {
    return this.port === 443 || this.key && this.certs;
  });

  /**
   * The type of server we're creating.
   *
   * @type {Boolean}
   * @public
   */
  Options.get('type', function type() {
    return this.spdy ? 'spdy' : (
      this.secure ? 'https' : 'http'
    );
  });

  //
  // Iterate over the spec and create getter and setters for each given option.
  // The setters will only set the value if it has not been set before.
  //
  Object.keys(spec).forEach(function each(method) {
    spec[method] = spec[method].toLowerCase();

    Options.set(method, function get() {
      return this.data[method];
    }, function set(value) {
      if (method in this.data) return this.data[method];

      var type = is(value);

      if (!~spec[method].indexOf(type)) {
        throw new Error([
          'The '+ name +' option `'+ method +'` only accepts '+ spec[method],
          ', you supplied it with an '+ type +' ('+ value +') instead.'
        ].join(' '));
      }

      return this.data[method] = value;
    });
  });

  return Options;
};
