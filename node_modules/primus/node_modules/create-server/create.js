'use strict';

var fusing = require('fusing')
  , os = require('os');

//
// Setup the options validators.
//
var Options = require('./options')('create-server', {
  ca:         'array, string',    // ca location.
  cert:       'array, string',    // certs location.
  close:      'function',         // close callback.
  cluster:    'number, boolean',  // create a cluster.
  cores:      'number',           // cores available on server.
  crl:        'array, string',    // crl location.
  error:      'function',         // error callback.
  gb:         'number',           // gigabytes of memory on machine.
  http:       'function',         // http server callback.
  https:      'function',         // https server callback.
  key:        'array, string',    // key location.
  listen:     'boolean',          // start listening to the given port.
  listening:  'function',         // server listening callback
  namespace:  'string',           // Namespace for cluster communication.
  pfx:        'array, string',    // pfx location.
  port:       'number',           // port number.
  redirect:   'number',           // redirect port number.
  request:    'function',         // request handler.
  root:       'string',           // root location of ssl certs.
  seed:       'number',           // seed for stick.
  spdy:       'function',         // spdy callback.
  spdys:      'boolean',          // spdy supported.
  upgrade:    'function',         // upgrade handler.
});

/**
 * Create a server for the given parameters.
 *
 * @constructor
 * @param {Mixed} options Server configuration.
 * @api public
 */
function Create(options, fns) {
  if (!(this instanceof Create)) return new Create(options, fns);

  this.options = this.defaults(fns, options);
  this.workers = [];
}

//
// Introduce syntax sugar.
//
require('fusing')(Create);

/**
 * Add some sane defaults to our options.
 *
 * @param {Mixed} args Options that we accept.
 * @returns {Object}
 * @api private
 */
Create.readable('defaults', function optional(args) {
  return new Options('number' === typeof args ? { port: args } : args, {
    gb: Math.round(os.totalmem() / 1073741824 * 100000) / 100000,
    namespace: 'create:server:ipc',
    seed: ~~(Math.random() * 1e9),
    cores: os.cpus().length,
    listen: true,
    port: 443,

    //
    // Determine SPDY support by trying to resolve the module, we don't want to
    // require it yet.
    //
    spdys: (function spdy() {
      try { return !!require.resolve('spdy'); }
      catch (e) { return false; }
    }())
  });
});

/**
 * Start up a node cluster instead doing just our thing.
 *
 * @param {Server} server The HTTP server.
 * @api private
 */
Create.readable('cluster', function stickycluster(server) {
  var cluster = require('cluster')
    , options = this.options
    , create = this
    , workers;

  //
  // Optimization: We know that node's processes start fucking up when they
  // reach about 1.7 - 2GB in memory because they are limited to V8's heap size.
  //
  if ('boolean' === typeof options.cluster) {
    if (Math.round(options.gb) / 1.7 > options.cores) {
      workers = options.cores;
    } else {
      workers = Math.round(options.gb / 1.7);
    }
  } else workers = options.cluster;

  if (!cluster.isMaster) {
    process.on('message', function message(namespace, socket) {
      if (options.namespace !== namespace) return;

      server.emit('connection', socket);
    });

    return server;
  }

  (function spawn(i, reboot) {
    var worker = create[i] = cluster.fork();

    worker.once('exit', function exit() {
      //
      // This worker seemed to have died, we should restart the server to ensure
      // full utilization of all server resources at all times.
      //
      spawn(i, true);
    });

    if (reboot || i + 1 === workers) return;
  }(0));
});

/**
 * Creates a new server with the given options.
 *
 * @returns {Server}
 * @api private
 */
Create.readable('createServer', function createServer() {
  switch (this.options.type) {
    case 'http':
    return require('http').createServer();

    case 'https':
    return require('https').createServer(this.options);

    case 'spdy':
    return require('spdy').createServer(this.options);
  }
});

/**
 * Hash out the IP address.
 *
 * @param {String} ip The IP address of the incoming connection.
 * @param {Number} seed The seed for the hasher.
 * @returns {Number}
 * @api private
 */
Create.readable('hash', function consistent(ip, seed) {
  var hash = (ip || '').split(/\.|\:/).reduce(function reduce(r, num) {
    r += parseInt(num, 10);
    r %= 2147483648;
    r += (r << 10);
    r %= 2147483648;
    r ^= r >> 6;

    return r;
  }, seed);

  hash += hash << 3;
  hash %= 2147483648;
  hash ^= hash >> 11;
  hash += hash << 15;
  hash %= 2147483648;

  return hash >>> 0;
});

//
// Expose the module.
//
Create.Options = Options;
module.exports = Create;
