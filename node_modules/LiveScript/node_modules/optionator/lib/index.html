<!DOCTYPE html><html lang="en"><head><title>node_modules/LiveScript/node_modules/optionator/lib/index</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../../../"><meta name="groc-document-path" content="node_modules/LiveScript/node_modules/optionator/lib/index"><meta name="groc-project-path" content="node_modules/LiveScript/node_modules/optionator/lib/index.js"><meta name="groc-github-url" content="https://github.com/DimensionSoftware/instant-skeleton"><link rel="stylesheet" type="text/css" media="all" href="../../../../../assets/style.css"><script type="text/javascript" src="../../../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/DimensionSoftware/instant-skeleton/blob/master/node_modules/LiveScript/node_modules/optionator/lib/index.js">node_modules/LiveScript/node_modules/optionator/lib/index.js</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>Generated by LiveScript 1.2.0</p></div></div><div class="code"><div class="wrapper">(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
  <span class="hljs-keyword">var</span> VERSION, ref$, id, map, compact, any, groupBy, chars, isItNaN, keys, Obj, camelize, deepIs, closestString, nameToRaw, dasherize, generateHelp, generateHelpForOption, parsedTypeCheck, parseType, parseLevn, camelizeKeys, parseString, main, toString$ = {}.toString, slice$ = [].slice;
  VERSION = <span class="hljs-string">'0.4.0'</span>;
  ref$ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'prelude-ls'</span>), id = ref$.id, map = ref$.map, compact = ref$.compact, any = ref$.any, groupBy = ref$.groupBy, chars = ref$.chars, isItNaN = ref$.isItNaN, keys = ref$.keys, Obj = ref$.Obj, camelize = ref$.camelize;
  deepIs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'deep-is'</span>);
  ref$ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./util'</span>), closestString = ref$.closestString, nameToRaw = ref$.nameToRaw, dasherize = ref$.dasherize;
  ref$ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./help'</span>), generateHelp = ref$.generateHelp, generateHelpForOption = ref$.generateHelpForOption;
  ref$ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'type-check'</span>), parsedTypeCheck = ref$.parsedTypeCheck, parseType = ref$.parseType;
  parseLevn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'levn'</span>).parsedTypeParse;
  camelizeKeys = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(obj)</span>{</span>
    <span class="hljs-keyword">var</span> key, value, results$ = {};
    <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> obj) {
      value = obj[key];
      results$[camelize(key)] = value;
    }
    <span class="hljs-keyword">return</span> results$;
  };
  parseString = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(string)</span>{</span>
    <span class="hljs-keyword">var</span> assignOpt, regex, replaceRegex, result;
    assignOpt = <span class="hljs-string">'--?[a-zA-Z][-a-z-A-Z0-9]*='</span>;
    regex = <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'(?:'</span> + assignOpt + <span class="hljs-string">')?(?:\'(?:\\\\\'|[^\'])+\'|"(?:\\\\"|[^"])+")|[^\'"\\s]+'</span>, <span class="hljs-string">'g'</span>);
    replaceRegex = <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'^('</span> + assignOpt + <span class="hljs-string">')?[\'"]([\\s\\S]*)[\'"]$'</span>);
    result = map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
      <span class="hljs-keyword">return</span> it.replace(replaceRegex, <span class="hljs-string">'$1$2'</span>);
    }, string.match(regex) || []);
    <span class="hljs-keyword">return</span> result;
  };
  main = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(libOptions)</span>{</span>
    <span class="hljs-keyword">var</span> opts, defaults, required, traverse, getOption, parse;
    opts = {};
    defaults = {};
    required = [];
    <span class="hljs-keyword">if</span> (toString$.call(libOptions.stdout).slice(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>) === <span class="hljs-string">'Undefined'</span>) {
      libOptions.stdout = process.stdout;
    }
    traverse = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(options)</span>{</span>
      <span class="hljs-keyword">var</span> i$, len$, option, name, e, parsedPossibilities, parsedType, j$, ref$, len1$, possibility, that, rawDependsType, dependsOpts, dependsType, alias;
      <span class="hljs-keyword">if</span> (toString$.call(options).slice(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>) !== <span class="hljs-string">'Array'</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'No options defined.'</span>);
      }
      <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = options.length; i$ &lt; len$; ++i$) {
        option = options[i$];
        <span class="hljs-keyword">if</span> (option.heading == <span class="hljs-literal">null</span>) {
          name = option.option;
          <span class="hljs-keyword">if</span> (opts[name] != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Option '"</span> + name + <span class="hljs-string">"' already defined."</span>);
          }
          <span class="hljs-keyword">if</span> (option.type === <span class="hljs-string">'Boolean'</span>) {
            option.boolean == <span class="hljs-literal">null</span> &amp;&amp; (option.boolean = <span class="hljs-literal">true</span>);
          }
          <span class="hljs-keyword">if</span> (option.parsedType == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (!option.type) {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"No type defined for option '"</span> + name + <span class="hljs-string">"'."</span>);
            }
            <span class="hljs-keyword">try</span> {
              option.parsedType = parseType(option.type);
            } <span class="hljs-keyword">catch</span> (e$) {
              e = e$;
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Option '"</span> + name + <span class="hljs-string">"': Error parsing type '"</span> + option.type + <span class="hljs-string">"': "</span> + e.message);
            }
          }
          <span class="hljs-keyword">if</span> (option[<span class="hljs-string">'default'</span>]) {
            <span class="hljs-keyword">try</span> {
              defaults[name] = parseLevn(option.parsedType, option[<span class="hljs-string">'default'</span>]);
            } <span class="hljs-keyword">catch</span> (e$) {
              e = e$;
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Option '"</span> + name + <span class="hljs-string">"': Error parsing default value '"</span> + option[<span class="hljs-string">'default'</span>] + <span class="hljs-string">"' for type '"</span> + option.type + <span class="hljs-string">"': "</span> + e.message);
            }
          }
          <span class="hljs-keyword">if</span> (option[<span class="hljs-string">'enum'</span>] &amp;&amp; !option.parsedPossiblities) {
            parsedPossibilities = [];
            parsedType = option.parsedType;
            <span class="hljs-keyword">for</span> (j$ = <span class="hljs-number">0</span>, len1$ = (ref$ = option[<span class="hljs-string">'enum'</span>]).length; j$ &lt; len1$; ++j$) {
              possibility = ref$[j$];
              <span class="hljs-keyword">try</span> {
                parsedPossibilities.push(parseLevn(parsedType, possibility));
              } <span class="hljs-keyword">catch</span> (e$) {
                e = e$;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Option '"</span> + name + <span class="hljs-string">"': Error parsing enum value '"</span> + possibility + <span class="hljs-string">"' for type '"</span> + option.type + <span class="hljs-string">"': "</span> + e.message);
              }
            }
            option.parsedPossibilities = parsedPossibilities;
          }
          <span class="hljs-keyword">if</span> (that = option.dependsOn) {
            <span class="hljs-keyword">if</span> (that.length) {
              ref$ = [].concat(option.dependsOn), rawDependsType = ref$[<span class="hljs-number">0</span>], dependsOpts = slice$.call(ref$, <span class="hljs-number">1</span>);
              dependsType = rawDependsType.toLowerCase();
              <span class="hljs-keyword">if</span> (dependsOpts.length) {
                <span class="hljs-keyword">if</span> (dependsType === <span class="hljs-string">'and'</span> || dependsType === <span class="hljs-string">'or'</span>) {
                  option.dependsOn = [dependsType].concat(slice$.call(dependsOpts));
                } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Option '"</span> + name + <span class="hljs-string">"': If you have more than one dependency, you must specify either 'and' or 'or'"</span>);
                }
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> ((ref$ = dependsType.toLowerCase()) === <span class="hljs-string">'and'</span> || ref$ === <span class="hljs-string">'or'</span>) {
                  option.dependsOn = <span class="hljs-literal">null</span>;
                } <span class="hljs-keyword">else</span> {
                  option.dependsOn = [<span class="hljs-string">'and'</span>, rawDependsType];
                }
              }
            } <span class="hljs-keyword">else</span> {
              option.dependsOn = <span class="hljs-literal">null</span>;
            }
          }
          <span class="hljs-keyword">if</span> (option.required) {
            required.push(name);
          }
          opts[name] = option;
          <span class="hljs-keyword">if</span> (option.alias || option.aliases) {
            <span class="hljs-keyword">if</span> (name === <span class="hljs-string">'NUM'</span>) {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"-NUM option can't have aliases."</span>);
            }
            <span class="hljs-keyword">if</span> (option.alias) {
              option.aliases == <span class="hljs-literal">null</span> &amp;&amp; (option.aliases = [].concat(option.alias));
            }
            <span class="hljs-keyword">for</span> (j$ = <span class="hljs-number">0</span>, len1$ = (ref$ = option.aliases).length; j$ &lt; len1$; ++j$) {
              alias = ref$[j$];
              <span class="hljs-keyword">if</span> (opts[alias] != <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Option '"</span> + alias + <span class="hljs-string">"' already defined."</span>);
              }
              opts[alias] = option;
            }
          }
        }
      }
    };
    traverse(libOptions.options);
    getOption = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name)</span>{</span>
      <span class="hljs-keyword">var</span> opt, possiblyMeant;
      opt = opts[name];
      <span class="hljs-keyword">if</span> (opt == <span class="hljs-literal">null</span>) {
        possiblyMeant = closestString(keys(opts), name);
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Invalid option '"</span> + nameToRaw(name) + <span class="hljs-string">"'"</span> + (possiblyMeant ? <span class="hljs-string">" - perhaps you meant '"</span> + nameToRaw(possiblyMeant) + <span class="hljs-string">"'?"</span> : <span class="hljs-string">'.'</span>));
      }
      <span class="hljs-keyword">return</span> opt;
    };
    parse = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(input, arg$)</span>{</span>
      <span class="hljs-keyword">var</span> slice, obj, positional, restPositional, overrideRequired, prop, setValue, setDefaults, checkRequired, mutuallyExclusiveError, checkMutuallyExclusive, checkDependency, checkDependencies, args, key, value, option, ref$, i$, len$, arg, that, result, short, argName, usingAssign, val, flags, len, j$, len1$, i, flag, opt, name, negated, noedName, valPrime;
      slice = (arg$ != <span class="hljs-literal">null</span>
        ? arg$
        : {}).slice;
      obj = {};
      positional = [];
      restPositional = <span class="hljs-literal">false</span>;
      overrideRequired = <span class="hljs-literal">false</span>;
      prop = <span class="hljs-literal">null</span>;
      setValue = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name, value)</span>{</span>
        <span class="hljs-keyword">var</span> opt, val, e, currentType;
        opt = getOption(name);
        <span class="hljs-keyword">if</span> (opt.boolean) {
          val = value;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">try</span> {
            val = parseLevn(opt.parsedType, value);
          } <span class="hljs-keyword">catch</span> (e$) {
            e = e$;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Invalid value for option '"</span> + name + <span class="hljs-string">"' - expected type "</span> + opt.type + <span class="hljs-string">", received value: "</span> + value + <span class="hljs-string">"."</span>);
          }
          <span class="hljs-keyword">if</span> (opt[<span class="hljs-string">'enum'</span>] &amp;&amp; !any(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
            <span class="hljs-keyword">return</span> deepIs(it, val);
          }, opt.parsedPossibilities)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Option "</span> + name + <span class="hljs-string">": '"</span> + val + <span class="hljs-string">"' not in ["</span> + opt[<span class="hljs-string">'enum'</span>].join(<span class="hljs-string">', '</span>) + <span class="hljs-string">"]."</span>);
          }
        }
        currentType = toString$.call(obj[name]).slice(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span> (obj[name] != <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (libOptions.concatRepeatedArrays &amp;&amp; currentType === <span class="hljs-string">'Array'</span>) {
            obj[name] = obj[name].concat(val);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (libOptions.mergeRepeatedObjects &amp;&amp; currentType === <span class="hljs-string">'Object'</span>) {
            import$(obj[name], val);
          } <span class="hljs-keyword">else</span> {
            obj[name] = val;
          }
        } <span class="hljs-keyword">else</span> {
          obj[name] = val;
        }
        <span class="hljs-keyword">if</span> (opt.restPositional) {
          restPositional = <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">if</span> (opt.overrideRequired) {
          overrideRequired = <span class="hljs-literal">true</span>;
        }
      };
      setDefaults = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
        <span class="hljs-keyword">var</span> name, ref$, value;
        <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> ref$ = defaults) {
          value = ref$[name];
          <span class="hljs-keyword">if</span> (obj[name] == <span class="hljs-literal">null</span>) {
            obj[name] = value;
          }
        }
      };
      checkRequired = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
        <span class="hljs-keyword">var</span> i$, ref$, len$, name;
        <span class="hljs-keyword">if</span> (overrideRequired) {
          <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = required).length; i$ &lt; len$; ++i$) {
          name = ref$[i$];
          <span class="hljs-keyword">if</span> (!obj[name]) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Option "</span> + nameToRaw(name) + <span class="hljs-string">" is required."</span>);
          }
        }
      };
      mutuallyExclusiveError = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(first, second)</span>{</span>
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"The options "</span> + nameToRaw(first) + <span class="hljs-string">" and "</span> + nameToRaw(second) + <span class="hljs-string">" are mutually exclusive - you cannot use them at the same time."</span>);
      };
      checkMutuallyExclusive = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
        <span class="hljs-keyword">var</span> rules, i$, len$, rule, present, j$, len1$, element, k$, len2$, opt;
        rules = libOptions.mutuallyExclusive;
        <span class="hljs-keyword">if</span> (!rules) {
          <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = rules.length; i$ &lt; len$; ++i$) {
          rule = rules[i$];
          present = <span class="hljs-literal">null</span>;
          <span class="hljs-keyword">for</span> (j$ = <span class="hljs-number">0</span>, len1$ = rule.length; j$ &lt; len1$; ++j$) {
            element = rule[j$];
            <span class="hljs-keyword">if</span> (toString$.call(element).slice(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>) === <span class="hljs-string">'Array'</span>) {
              <span class="hljs-keyword">for</span> (k$ = <span class="hljs-number">0</span>, len2$ = element.length; k$ &lt; len2$; ++k$) {
                opt = element[k$];
                <span class="hljs-keyword">if</span> (opt <span class="hljs-keyword">in</span> obj) {
                  <span class="hljs-keyword">if</span> (present != <span class="hljs-literal">null</span>) {
                    mutuallyExclusiveError(present, opt);
                  } <span class="hljs-keyword">else</span> {
                    present = opt;
                    <span class="hljs-keyword">break</span>;
                  }
                }
              }
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">if</span> (element <span class="hljs-keyword">in</span> obj) {
                <span class="hljs-keyword">if</span> (present != <span class="hljs-literal">null</span>) {
                  mutuallyExclusiveError(present, element);
                } <span class="hljs-keyword">else</span> {
                  present = element;
                }
              }
            }
          }
        }
      };
      checkDependency = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(option)</span>{</span>
        <span class="hljs-keyword">var</span> dependsOn, type, targetOptionNames, i$, len$, targetOptionName, targetOption;
        dependsOn = option.dependsOn;
        <span class="hljs-keyword">if</span> (!dependsOn || option.dependenciesMet) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        type = dependsOn[<span class="hljs-number">0</span>], targetOptionNames = slice$.call(dependsOn, <span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = targetOptionNames.length; i$ &lt; len$; ++i$) {
          targetOptionName = targetOptionNames[i$];
          targetOption = obj[targetOptionName];
          <span class="hljs-keyword">if</span> (targetOption &amp;&amp; checkDependency(targetOption)) {
            <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'or'</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'and'</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"The option '"</span> + option.option + <span class="hljs-string">"' did not have its dependencies met."</span>);
          }
        }
        <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'and'</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"The option '"</span> + option.option + <span class="hljs-string">"' did not meet any of its dependencies."</span>);
        }
      };
      checkDependencies = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
        <span class="hljs-keyword">var</span> name;
        <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> obj) {
          checkDependency(opts[name]);
        }
      };
      <span class="hljs-keyword">switch</span> (toString$.call(input).slice(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>)) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'String'</span>:
        args = parseString(input.slice(slice != <span class="hljs-literal">null</span> ? slice : <span class="hljs-number">0</span>));
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">'Array'</span>:
        args = input.slice(slice != <span class="hljs-literal">null</span> ? slice : <span class="hljs-number">2</span>);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">'Object'</span>:
        obj = {};
        <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> input) {
          value = input[key];
          <span class="hljs-keyword">if</span> (key !== <span class="hljs-string">'_'</span>) {
            option = getOption(dasherize(key));
            <span class="hljs-keyword">if</span> (parsedTypeCheck(option.parsedType, value)) {
              obj[option.option] = value;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Option '"</span> + option.option + <span class="hljs-string">"': Invalid type for '"</span> + value + <span class="hljs-string">"' - expected type '"</span> + option.type + <span class="hljs-string">"'."</span>);
            }
          }
        }
        checkMutuallyExclusive();
        checkDependencies();
        setDefaults();
        checkRequired();
        <span class="hljs-keyword">return</span> ref$ = camelizeKeys(obj), ref$._ = input._ || [], ref$;
      <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Invalid argument to 'parse': "</span> + input + <span class="hljs-string">"."</span>);
      }
      <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = args.length; i$ &lt; len$; ++i$) {
        arg = args[i$];
        <span class="hljs-keyword">if</span> (arg === <span class="hljs-string">'--'</span>) {
          restPositional = <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (restPositional) {
          positional.push(arg);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (that = arg.match(<span class="hljs-regexp">/^(--?)([a-zA-Z][-a-zA-Z0-9]*)(=)?(.*)?$/</span>)) {
            result = that;
            <span class="hljs-keyword">if</span> (prop) {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Value for '"</span> + prop + <span class="hljs-string">"' of type '"</span> + getOption(prop).type + <span class="hljs-string">"' required."</span>);
            }
            short = result[<span class="hljs-number">1</span>].length === <span class="hljs-number">1</span>;
            argName = result[<span class="hljs-number">2</span>];
            usingAssign = result[<span class="hljs-number">3</span>] != <span class="hljs-literal">null</span>;
            val = result[<span class="hljs-number">4</span>];
            <span class="hljs-keyword">if</span> (usingAssign &amp;&amp; val == <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"No value for '"</span> + argName + <span class="hljs-string">"' specified."</span>);
            }
            <span class="hljs-keyword">if</span> (short) {
              flags = chars(argName);
              len = flags.length;
              <span class="hljs-keyword">for</span> (j$ = <span class="hljs-number">0</span>, len1$ = flags.length; j$ &lt; len1$; ++j$) {
                i = j$;
                flag = flags[j$];
                opt = getOption(flag);
                name = opt.option;
                <span class="hljs-keyword">if</span> (restPositional) {
                  positional.push(flag);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt.boolean) {
                  setValue(name, <span class="hljs-literal">true</span>);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i === len - <span class="hljs-number">1</span>) {
                  <span class="hljs-keyword">if</span> (usingAssign) {
                    setValue(name, val);
                  } <span class="hljs-keyword">else</span> {
                    prop = name;
                  }
                } <span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Can't set argument '"</span> + flag + <span class="hljs-string">"' when not last flag in a group of short flags."</span>);
                }
              }
            } <span class="hljs-keyword">else</span> {
              negated = <span class="hljs-literal">false</span>;
              <span class="hljs-keyword">if</span> (that = argName.match(<span class="hljs-regexp">/^no-(.+)$/</span>)) {
                negated = <span class="hljs-literal">true</span>;
                noedName = that[<span class="hljs-number">1</span>];
                opt = getOption(noedName);
              } <span class="hljs-keyword">else</span> {
                opt = getOption(argName);
              }
              name = opt.option;
              <span class="hljs-keyword">if</span> (opt.boolean) {
                valPrime = usingAssign ? parseLevn([{
                  type: <span class="hljs-string">'Boolean'</span>
                }], val) : <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">if</span> (negated) {
                  setValue(name, !valPrime);
                } <span class="hljs-keyword">else</span> {
                  setValue(name, valPrime);
                }
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (negated) {
                  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Only use 'no-' prefix for Boolean options, not with '"</span> + noedName + <span class="hljs-string">"'."</span>);
                }
                <span class="hljs-keyword">if</span> (usingAssign) {
                  setValue(name, val);
                } <span class="hljs-keyword">else</span> {
                  prop = name;
                }
              }
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (that = arg.match(<span class="hljs-regexp">/^-([0-9]+(?:\.[0-9]+)?)$/</span>)) {
            opt = opts.NUM;
            <span class="hljs-keyword">if</span> (!opt) {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'No -NUM option defined.'</span>);
            }
            setValue(opt.option, that[<span class="hljs-number">1</span>]);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (prop) {
              setValue(prop, arg);
              prop = <span class="hljs-literal">null</span>;
            } <span class="hljs-keyword">else</span> {
              positional.push(arg);
            }
          }
        }
      }
      checkMutuallyExclusive();
      checkDependencies();
      setDefaults();
      checkRequired();
      <span class="hljs-keyword">return</span> ref$ = camelizeKeys(obj), ref$._ = positional, ref$;
    };
    <span class="hljs-keyword">return</span> {
      parse: parse,
      generateHelp: generateHelp(libOptions),
      generateHelpForOption: generateHelpForOption(getOption, libOptions)
    };
  };
  main.VERSION = VERSION;
  module.exports = main;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">import$</span><span class="hljs-params">(obj, src)</span>{</span>
    <span class="hljs-keyword">var</span> own = {}.hasOwnProperty;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> src) <span class="hljs-keyword">if</span> (own.call(src, key)) obj[key] = src[key];
    <span class="hljs-keyword">return</span> obj;
  }
}).call(<span class="hljs-keyword">this</span>);</div></div></div></div></body></html>