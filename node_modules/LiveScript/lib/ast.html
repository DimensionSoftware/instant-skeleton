<!DOCTYPE html><html lang="en"><head><title>node_modules/LiveScript/lib/ast</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../"><meta name="groc-document-path" content="node_modules/LiveScript/lib/ast"><meta name="groc-project-path" content="node_modules/LiveScript/lib/ast.js"><meta name="groc-github-url" content="https://github.com/DimensionSoftware/instant-skeleton"><link rel="stylesheet" type="text/css" media="all" href="../../../assets/style.css"><script type="text/javascript" src="../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/DimensionSoftware/instant-skeleton/blob/master/node_modules/LiveScript/lib/ast.js">node_modules/LiveScript/lib/ast.js</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>Generated by LiveScript 1.3.0</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> fold, path, Node, Negatable, Block, Atom, Literal, Var, Key, Index, Slice, Chain, Call, List, Obj, Prop, Arr, Unary, Binary, Assign, Import, In, Existence, Fun, Class, Super, Parens, Splat, Jump, Throw, Return, While, For, Try, Switch, Case, If, Label, Cascade, JS, Require, Util, Vars, DECLS, ref$, UTILS, LEVEL_TOP, LEVEL_PAREN, LEVEL_LIST, LEVEL_COND, LEVEL_OP, LEVEL_CALL, PREC, TAB, ID, SIMPLENUM, slice$ = [].slice, toString$ = {}.toString;
fold = <span class="hljs-built_in">require</span>(<span class="hljs-string">'prelude-ls'</span>).fold;
path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
(Node = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
  <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'unimplemented'</span>);
}).prototype = {
  compile: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(options, level)</span>{</span>
    <span class="hljs-keyword">var</span> o, node, code, that, i$, len$, tmp;
    o = import$({}, options);
    <span class="hljs-keyword">if</span> (level != <span class="hljs-literal">null</span>) {
      o.level = level;
    }
    node = <span class="hljs-keyword">this</span>.unfoldSoak(o) || <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">if</span> (o.level &amp;&amp; node.isStatement()) {
      <span class="hljs-keyword">return</span> node.compileClosure(o);
    }
    code = (node.tab = o.indent, node).compileNode(o);
    <span class="hljs-keyword">if</span> (that = node.temps) {
      <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = that.length; i$ &lt; len$; ++i$) {
        tmp = that[i$];
        o.scope.free(tmp);
      }
    }
    <span class="hljs-keyword">return</span> code;
  },
  compileClosure: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> that, fun, call, hasArgs, hasThis;
    <span class="hljs-keyword">if</span> (that = <span class="hljs-keyword">this</span>.getJump()) {
      that.carp(<span class="hljs-string">'inconvertible statement'</span>);
    }
    fun = Fun([], Block(<span class="hljs-keyword">this</span>));
    call = Call();
    <span class="hljs-keyword">this</span>.traverseChildren(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
      <span class="hljs-keyword">switch</span> (it.value) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'this'</span>:
        hasThis = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">'arguments'</span>:
        hasArgs = it.value = <span class="hljs-string">'args$'</span>;
      }
    });
    <span class="hljs-keyword">if</span> (hasThis) {
      call.args.push(Literal(<span class="hljs-string">'this'</span>));
      call.method = <span class="hljs-string">'.call'</span>;
    }
    <span class="hljs-keyword">if</span> (hasArgs) {
      call.args.push(Literal(<span class="hljs-string">'arguments'</span>));
      fun.params.push(Var(<span class="hljs-string">'args$'</span>));
    }
    <span class="hljs-keyword">return</span> Parens(Chain((fun.wrapper = <span class="hljs-literal">true</span>, fun[<span class="hljs-string">'void'</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'void'</span>], fun), [call]), <span class="hljs-literal">true</span>).compile(o);
  },
  compileBlock: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, node)</span>{</span>
    <span class="hljs-keyword">var</span> that;
    <span class="hljs-keyword">if</span> (that = node != <span class="hljs-literal">null</span> ? node.compile(o, LEVEL_TOP) : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"{\n"</span> + that + <span class="hljs-string">"\n"</span> + <span class="hljs-keyword">this</span>.tab + <span class="hljs-string">"}"</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-string">'{}'</span>;
    }
  },
  cache: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, once, level)</span>{</span>
    <span class="hljs-keyword">var</span> ref$, sub, ref;
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isComplex()) {
      <span class="hljs-keyword">return</span> [ref$ = level != <span class="hljs-literal">null</span> ? <span class="hljs-keyword">this</span>.compile(o, level) : <span class="hljs-keyword">this</span>, ref$];
    }
    sub = Assign(ref = Var(o.scope.temporary()), <span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">if</span> (level != <span class="hljs-literal">null</span>) {
      sub = sub.compile(o, level);
      <span class="hljs-keyword">if</span> (once) {
        o.scope.free(ref.value);
      }
      <span class="hljs-keyword">return</span> [sub, ref.value];
    }
    <span class="hljs-keyword">if</span> (once) {
      <span class="hljs-keyword">return</span> [sub, (ref.temp = <span class="hljs-literal">true</span>, ref)];
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> [sub, ref, [ref.value]];
    }
  },
  compileLoopReference: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, name, ret)</span>{</span>
    <span class="hljs-keyword">var</span> ref$, asn, tmp;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Var &amp;&amp; o.scope.check(<span class="hljs-keyword">this</span>.value) || <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Unary &amp;&amp; ((ref$ = <span class="hljs-keyword">this</span>.op) === <span class="hljs-string">'+'</span> || ref$ === <span class="hljs-string">'-'</span>) &amp;&amp; (-<span class="hljs-number">1</span> / <span class="hljs-number">0</span> &lt; (ref$ = +<span class="hljs-keyword">this</span>.it.value) &amp;&amp; ref$ &lt; <span class="hljs-number">1</span> / <span class="hljs-number">0</span>) || <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Literal &amp;&amp; !<span class="hljs-keyword">this</span>.isComplex()) {
      <span class="hljs-keyword">return</span> [ref$ = <span class="hljs-keyword">this</span>.compile(o), ref$];
    }
    asn = Assign(Var(tmp = o.scope.temporary(name)), <span class="hljs-keyword">this</span>);
    ret || (asn[<span class="hljs-string">'void'</span>] = <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">return</span> [tmp, asn.compile(o, ret ? LEVEL_CALL : LEVEL_PAREN)];
  },
  eachChild: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn)</span>{</span>
    <span class="hljs-keyword">var</span> i$, ref$, len$, name, child, j$, len1$, i, node, that;
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = <span class="hljs-keyword">this</span>.children).length; i$ &lt; len$; ++i$) {
      name = ref$[i$];
      <span class="hljs-keyword">if</span> (child = <span class="hljs-keyword">this</span>[name]) {
        <span class="hljs-keyword">if</span> (<span class="hljs-string">'length'</span> <span class="hljs-keyword">in</span> child) {
          <span class="hljs-keyword">for</span> (j$ = <span class="hljs-number">0</span>, len1$ = child.length; j$ &lt; len1$; ++j$) {
            i = j$;
            node = child[j$];
            <span class="hljs-keyword">if</span> (that = fn(node, name, i)) {
              <span class="hljs-keyword">return</span> that;
            }
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> ((that = fn(child, name)) != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> that;
          }
        }
      }
    }
  },
  traverseChildren: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, xscope)</span>{</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.eachChild(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node, name, index)</span>{</span>
      <span class="hljs-keyword">var</span> ref$;
      <span class="hljs-keyword">return</span> (ref$ = fn(node, <span class="hljs-keyword">this</span>$, name, index)) != <span class="hljs-literal">null</span>
        ? ref$
        : node.traverseChildren(fn, xscope);
    });
  },
  anaphorize: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> base, name, ref$;
    <span class="hljs-keyword">this</span>.children = <span class="hljs-keyword">this</span>.aTargets;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eachChild(hasThat)) {
      <span class="hljs-keyword">if</span> ((base = <span class="hljs-keyword">this</span>)[name = <span class="hljs-keyword">this</span>.aSource] <span class="hljs-keyword">instanceof</span> Existence) {
        base = base[name];
        name = <span class="hljs-string">'it'</span>;
      }
      <span class="hljs-keyword">if</span> (base[name].value !== <span class="hljs-string">'that'</span>) {
        base[name] = Assign(Var(<span class="hljs-string">'that'</span>), base[name]);
      }
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasThat</span><span class="hljs-params">(it)</span>{</span>
      <span class="hljs-keyword">var</span> that;
      <span class="hljs-keyword">return</span> it.value === <span class="hljs-string">'that'</span> || ((that = it.aSource)
        ? (that = it[that]) ? hasThat(that) : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>
        : it.eachChild(hasThat));
    }
    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.children;
    <span class="hljs-keyword">return</span> ref$ = <span class="hljs-keyword">this</span>[<span class="hljs-keyword">this</span>.aSource], ref$.cond = <span class="hljs-literal">true</span>, ref$;
  },
  carp: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(msg, type)</span>{</span>
    type == <span class="hljs-literal">null</span> &amp;&amp; (type = <span class="hljs-built_in">SyntaxError</span>);
    <span class="hljs-keyword">throw</span> type(msg + <span class="hljs-string">" on line "</span> + (<span class="hljs-keyword">this</span>.line || <span class="hljs-keyword">this</span>.traverseChildren(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
      <span class="hljs-keyword">return</span> it.line;
    })));
  },
  delegate: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(names, fn)</span>{</span>
    <span class="hljs-keyword">var</span> i$, len$;
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = names.length; i$ &lt; len$; ++i$) {
      (fn$.call(<span class="hljs-keyword">this</span>, names[i$]));
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn$</span><span class="hljs-params">(name)</span>{</span>
      <span class="hljs-keyword">this</span>[name] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
        <span class="hljs-keyword">return</span> fn.call(<span class="hljs-keyword">this</span>, name, it);
      };
    }
  },
  children: [],
  terminator: <span class="hljs-string">';'</span>,
  isComplex: YES,
  isStatement: NO,
  isAssignable: NO,
  isCallable: NO,
  isEmpty: NO,
  isArray: NO,
  isString: NO,
  isRegex: NO,
  isMatcher: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isString() || <span class="hljs-keyword">this</span>.isRegex();
  },
  assigns: NO,
  ripName: VOID,
  unfoldSoak: VOID,
  unfoldAssign: VOID,
  unparen: THIS,
  unwrap: THIS,
  maybeKey: THIS,
  expandSlice: THIS,
  varName: <span class="hljs-built_in">String</span>,
  getAccessors: VOID,
  getCall: VOID,
  getDefault: VOID,
  getJump: VOID,
  invert: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> Unary(<span class="hljs-string">'!'</span>, <span class="hljs-keyword">this</span>, <span class="hljs-literal">true</span>);
  },
  invertCheck: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">if</span> (it.inverted) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.invert();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
  },
  addElse: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($else)</span>{</span>
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'else'</span>] = $<span class="hljs-keyword">else</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  },
  makeReturn: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arref)</span>{</span>
    <span class="hljs-keyword">if</span> (arref) {
      <span class="hljs-keyword">return</span> Call.make(JS(arref + <span class="hljs-string">'.push'</span>), [<span class="hljs-keyword">this</span>]);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> Return(<span class="hljs-keyword">this</span>);
    }
  },
  makeObjReturn: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arref)</span>{</span>
    <span class="hljs-keyword">var</span> base, items;
    <span class="hljs-keyword">if</span> (arref) {
      base = <span class="hljs-keyword">this</span>.lines[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lines[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> If) {
        base = base.then.lines[<span class="hljs-number">0</span>];
      }
      items = base.items;
      <span class="hljs-keyword">if</span> (items[<span class="hljs-number">0</span>] == <span class="hljs-literal">null</span> || items[<span class="hljs-number">1</span>] == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">this</span>.carp(<span class="hljs-string">'must specify both key and value for object comprehension'</span>);
      }
      <span class="hljs-keyword">return</span> Assign(Chain(Var(arref)).add(Index(items[<span class="hljs-number">0</span>], <span class="hljs-string">'.'</span>, <span class="hljs-literal">true</span>)), items[<span class="hljs-number">1</span>]);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> Return(<span class="hljs-keyword">this</span>);
    }
  },
  show: <span class="hljs-built_in">String</span>,
  toString: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(idt)</span>{</span>
    <span class="hljs-keyword">var</span> tree, that;
    idt || (idt = <span class="hljs-string">''</span>);
    tree = <span class="hljs-string">'\n'</span> + idt + <span class="hljs-keyword">this</span>.constructor.displayName;
    <span class="hljs-keyword">if</span> (that = <span class="hljs-keyword">this</span>.show()) {
      tree += <span class="hljs-string">' '</span> + that;
    }
    <span class="hljs-keyword">this</span>.eachChild(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
      tree += it.toString(idt + TAB);
    });
    <span class="hljs-keyword">return</span> tree;
  },
  stringify: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(space)</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-keyword">this</span>, <span class="hljs-literal">null</span>, space);
  },
  toJSON: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> import$({
      type: <span class="hljs-keyword">this</span>.constructor.displayName
    }, <span class="hljs-keyword">this</span>);
  }
};
exports.parse = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(json)</span>{</span>
  <span class="hljs-keyword">return</span> exports.fromJSON(<span class="hljs-built_in">JSON</span>.parse(json));
};
exports.fromJSON = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fromJSON</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">var</span> that, node, key, val, i$, len$, v, results$ = [];
    <span class="hljs-keyword">if</span> (!(it &amp;&amp; <span class="hljs-keyword">typeof</span> it === <span class="hljs-string">'object'</span>)) {
      <span class="hljs-keyword">return</span> it;
    }
    <span class="hljs-keyword">if</span> (that = it.type) {
      node = clone$(exports[that].prototype);
      <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> it) {
        val = it[key];
        node[key] = fromJSON(val);
      }
      <span class="hljs-keyword">return</span> node;
    }
    <span class="hljs-keyword">if</span> (it.length != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = it.length; i$ &lt; len$; ++i$) {
        v = it[i$];
        results$.push(fromJSON(v));
      }
      <span class="hljs-keyword">return</span> results$;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> it;
    }
  }
  <span class="hljs-keyword">return</span> fromJSON;
}());
Negatable = {
  show: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.negated &amp;&amp; <span class="hljs-string">'!'</span>;
  },
  invert: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">this</span>.negated = !<span class="hljs-keyword">this</span>.negated;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }
};
exports.Block = Block = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Block, superclass).displayName = <span class="hljs-string">'Block'</span>, Block), superclass).prototype, constructor = Block;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Block</span><span class="hljs-params">(body)</span>{</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    body || (body = []);
    <span class="hljs-keyword">if</span> (<span class="hljs-string">'length'</span> <span class="hljs-keyword">in</span> body) {
      <span class="hljs-keyword">this</span>$.lines = body;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>$.lines = [];
      <span class="hljs-keyword">this</span>$.add(body);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.children = [<span class="hljs-string">'lines'</span>];
  prototype.toJSON = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.back;
    <span class="hljs-keyword">return</span> superclass.prototype.toJSON.call(<span class="hljs-keyword">this</span>);
  };
  prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">var</span> that, ref$;
    it = it.unparen();
    <span class="hljs-keyword">switch</span> (<span class="hljs-literal">false</span>) {
    <span class="hljs-keyword">case</span> !(that = <span class="hljs-keyword">this</span>.back):
      that.add(it);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> !(that = it.lines):
      (ref$ = <span class="hljs-keyword">this</span>.lines).push.apply(ref$, that);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">this</span>.lines.push(it);
      <span class="hljs-keyword">if</span> (that = (ref$ = it.back, <span class="hljs-keyword">delete</span> it.back, ref$)) {
        <span class="hljs-keyword">this</span>.back = that;
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  prototype.prepend = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> ref$;
    (ref$ = <span class="hljs-keyword">this</span>.lines).splice.apply(ref$, [<span class="hljs-keyword">this</span>.neck(), <span class="hljs-number">0</span>].concat(slice$.call(<span class="hljs-built_in">arguments</span>)));
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  prototype.pipe = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(target, type)</span>{</span>
    <span class="hljs-keyword">var</span> args;
    args = type === <span class="hljs-string">'|&gt;'</span> ? <span class="hljs-keyword">this</span>.lines.pop() : target;
    <span class="hljs-keyword">if</span> (toString$.call(args).slice(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>) !== <span class="hljs-string">'Array'</span>) {
      args = [args];
    }
    <span class="hljs-keyword">switch</span> (type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'|&gt;'</span>:
      <span class="hljs-keyword">this</span>.lines.push(Call.make(target, args, {
        pipe: <span class="hljs-literal">true</span>
      }));
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'&lt;|'</span>:
      <span class="hljs-keyword">this</span>.lines.push(Call.make(<span class="hljs-keyword">this</span>.lines.pop(), args));
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  prototype.unwrap = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lines.length === <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.lines[<span class="hljs-number">0</span>];
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
  };
  prototype.chomp = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> lines, i, that;
    lines = <span class="hljs-keyword">this</span>.lines;
    i = lines.length;
    <span class="hljs-keyword">while</span> (that = lines[--i]) {
      <span class="hljs-keyword">if</span> (!that.comment) {
        <span class="hljs-keyword">break</span>;
      }
    }
    lines.length = i + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  prototype.neck = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> pos, i$, ref$, len$, x;
    pos = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = <span class="hljs-keyword">this</span>.lines).length; i$ &lt; len$; ++i$) {
      x = ref$[i$];
      <span class="hljs-keyword">if</span> (!(x.comment || x <span class="hljs-keyword">instanceof</span> Literal)) {
        <span class="hljs-keyword">break</span>;
      }
      ++pos;
    }
    <span class="hljs-keyword">return</span> pos;
  };
  prototype.isComplex = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> ref$;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.lines.length &gt; <span class="hljs-number">1</span> || ((ref$ = <span class="hljs-keyword">this</span>.lines[<span class="hljs-number">0</span>]) != <span class="hljs-literal">null</span> ? ref$.isComplex() : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>);
  };
  prototype.delegate([<span class="hljs-string">'isCallable'</span>, <span class="hljs-string">'isArray'</span>, <span class="hljs-string">'isString'</span>, <span class="hljs-string">'isRegex'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">var</span> ref$, ref1$;
    <span class="hljs-keyword">return</span> (ref$ = (ref1$ = <span class="hljs-keyword">this</span>.lines)[ref1$.length - <span class="hljs-number">1</span>]) != <span class="hljs-literal">null</span> ? ref$[it]() : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>;
  });
  prototype.getJump = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">var</span> i$, ref$, len$, node, that;
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = <span class="hljs-keyword">this</span>.lines).length; i$ &lt; len$; ++i$) {
      node = ref$[i$];
      <span class="hljs-keyword">if</span> (that = node.getJump(it)) {
        <span class="hljs-keyword">return</span> that;
      }
    }
  };
  prototype.makeReturn = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">var</span> that, ref$, key$, ref1$;
    <span class="hljs-keyword">this</span>.chomp();
    <span class="hljs-keyword">if</span> (that = (ref1$ = ref$ = <span class="hljs-keyword">this</span>.lines)[key$ = ref1$.length - <span class="hljs-number">1</span>] != <span class="hljs-literal">null</span> ? ref$[key$] = ref$[key$].makeReturn(it) : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>) {
      <span class="hljs-keyword">if</span> (that <span class="hljs-keyword">instanceof</span> Return &amp;&amp; !that.it) {
        --<span class="hljs-keyword">this</span>.lines.length;
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  prototype.compile = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, level)</span>{</span>
    <span class="hljs-keyword">var</span> tab, codes, res$, i$, ref$, len$, node, code;
    level == <span class="hljs-literal">null</span> &amp;&amp; (level = o.level);
    <span class="hljs-keyword">if</span> (level) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileExpressions(o, level);
    }
    o.block = <span class="hljs-keyword">this</span>;
    tab = o.indent;
    res$ = [];
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = <span class="hljs-keyword">this</span>.lines).length; i$ &lt; len$; ++i$) {
      node = ref$[i$];
      node = node.unfoldSoak(o) || node;
      <span class="hljs-keyword">if</span> (!(code = (node.front = <span class="hljs-literal">true</span>, node).compile(o, level))) {
        <span class="hljs-keyword">continue</span>;
      }
      node.isStatement() || (code += node.terminator);
      res$.push(tab + code);
    }
    codes = res$;
    <span class="hljs-keyword">return</span> codes.join(<span class="hljs-string">'\n'</span>);
  };
  prototype.compileRoot = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(options)</span>{</span>
    <span class="hljs-keyword">var</span> o, saveTo, ref$, bare, prefix, ref1$, code;
    o = (import$({
      level: LEVEL_TOP,
      scope: <span class="hljs-keyword">this</span>.scope = Scope.root = <span class="hljs-keyword">new</span> Scope
    }, options));
    <span class="hljs-keyword">if</span> (saveTo = (ref$ = o.saveScope, <span class="hljs-keyword">delete</span> o.saveScope, ref$)) {
      o.scope = saveTo.savedScope || (saveTo.savedScope = o.scope);
    }
    <span class="hljs-keyword">delete</span> o.filename;
    o.indent = (bare = (ref$ = o.bare, <span class="hljs-keyword">delete</span> o.bare, ref$)) ? <span class="hljs-string">''</span> : TAB;
    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^\s*(?:[/#]|javascript:)/</span>.test((ref$ = <span class="hljs-keyword">this</span>.lines[<span class="hljs-number">0</span>]) != <span class="hljs-literal">null</span> ? ref$.code : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>)) {
      prefix = <span class="hljs-keyword">this</span>.lines.shift().code + <span class="hljs-string">'\n'</span>;
    }
    <span class="hljs-keyword">if</span> ((ref1$ = o.eval, <span class="hljs-keyword">delete</span> o.eval, ref1$) &amp;&amp; <span class="hljs-keyword">this</span>.chomp().lines.length) {
      <span class="hljs-keyword">if</span> (bare) {
        <span class="hljs-keyword">this</span>.lines.push(Parens(<span class="hljs-keyword">this</span>.lines.pop()));
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.makeReturn();
      }
    }
    code = <span class="hljs-keyword">this</span>.compileWithDeclarations(o);
    bare || (code = <span class="hljs-string">"(function(){\n"</span> + code + <span class="hljs-string">"\n}).call(this);\n"</span>);
    <span class="hljs-keyword">return</span> [prefix] + code;
  };
  prototype.compileWithDeclarations = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> pre, i, rest, post, that;
    o.level = LEVEL_TOP;
    pre = <span class="hljs-string">''</span>;
    <span class="hljs-keyword">if</span> (i = <span class="hljs-keyword">this</span>.neck()) {
      rest = <span class="hljs-keyword">this</span>.lines.splice(i, <span class="hljs-number">9e9</span>);
      pre = <span class="hljs-keyword">this</span>.compile(o);
      <span class="hljs-keyword">this</span>.lines = rest;
    }
    <span class="hljs-keyword">if</span> (!(post = <span class="hljs-keyword">this</span>.compile(o))) {
      <span class="hljs-keyword">return</span> pre;
    }
    <span class="hljs-keyword">return</span> (pre &amp;&amp; pre + <span class="hljs-string">"\n"</span>) + ((that = <span class="hljs-keyword">this</span>.scope) ? that.emit(post, o.indent) : post);
  };
  prototype.compileExpressions = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, level)</span>{</span>
    <span class="hljs-keyword">var</span> lines, i, that, code, last, i$, len$, node;
    lines = <span class="hljs-keyword">this</span>.chomp().lines;
    i = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (that = lines[++i]) {
      <span class="hljs-keyword">if</span> (that.comment) {
        lines.splice(i--, <span class="hljs-number">1</span>);
      }
    }
    <span class="hljs-keyword">if</span> (!lines.length) {
      lines.push(Literal(<span class="hljs-string">'void'</span>));
    }
    lines[<span class="hljs-number">0</span>].front = <span class="hljs-keyword">this</span>.front;
    lines[lines.length - <span class="hljs-number">1</span>][<span class="hljs-string">'void'</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'void'</span>];
    <span class="hljs-keyword">if</span> (!lines[<span class="hljs-number">1</span>]) {
      <span class="hljs-keyword">return</span> lines[<span class="hljs-number">0</span>].compile(o, level);
    }
    code = <span class="hljs-string">''</span>;
    last = lines.pop();
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = lines.length; i$ &lt; len$; ++i$) {
      node = lines[i$];
      code += (node[<span class="hljs-string">'void'</span>] = <span class="hljs-literal">true</span>, node).compile(o, LEVEL_PAREN) + <span class="hljs-string">', '</span>;
    }
    code += last.compile(o, LEVEL_PAREN);
    <span class="hljs-keyword">if</span> (level &lt; LEVEL_LIST) {
      <span class="hljs-keyword">return</span> code;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"("</span> + code + <span class="hljs-string">")"</span>;
    }
  };
  <span class="hljs-keyword">return</span> Block;
}(Node));
Atom = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Atom, superclass).displayName = <span class="hljs-string">'Atom'</span>, Atom), superclass).prototype, constructor = Atom;
  prototype.show = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value;
  };
  prototype.isComplex = NO;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Atom</span><span class="hljs-params">()</span>{</span>
    Atom.superclass.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
  }
  <span class="hljs-keyword">return</span> Atom;
}(Node));
exports.Literal = Literal = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Literal, superclass).displayName = <span class="hljs-string">'Literal'</span>, Literal), superclass).prototype, constructor = Literal;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Literal</span><span class="hljs-params">(value)</span>{</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">this</span>$.value = value;
    <span class="hljs-keyword">if</span> (value.js) {
      <span class="hljs-keyword">return</span> JS(value + <span class="hljs-string">""</span>, <span class="hljs-literal">true</span>);
    }
    <span class="hljs-keyword">if</span> (value === <span class="hljs-string">'super'</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Super;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> ref$;
    <span class="hljs-keyword">return</span> (ref$ = <span class="hljs-keyword">this</span>.value) === <span class="hljs-string">'void'</span> || ref$ === <span class="hljs-string">'null'</span>;
  };
  prototype.isCallable = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> ref$;
    <span class="hljs-keyword">return</span> (ref$ = <span class="hljs-keyword">this</span>.value) === <span class="hljs-string">'this'</span> || ref$ === <span class="hljs-string">'eval'</span> || ref$ === <span class="hljs-string">'..'</span>;
  };
  prototype.isString = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &lt;= <span class="hljs-string">'\'"'</span>.indexOf((<span class="hljs-keyword">this</span>.value + <span class="hljs-string">""</span>).charAt());
  };
  prototype.isRegex = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.value + <span class="hljs-string">""</span>).charAt() === <span class="hljs-string">'/'</span>;
  };
  prototype.isComplex = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isRegex() || <span class="hljs-keyword">this</span>.value === <span class="hljs-string">'debugger'</span>;
  };
  prototype.isWhat = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">switch</span> (<span class="hljs-literal">false</span>) {
    <span class="hljs-keyword">case</span> !<span class="hljs-keyword">this</span>.isEmpty():
      <span class="hljs-keyword">return</span> <span class="hljs-string">'empty'</span>;
    <span class="hljs-keyword">case</span> !<span class="hljs-keyword">this</span>.isCallable():
      <span class="hljs-keyword">return</span> <span class="hljs-string">'callable'</span>;
    <span class="hljs-keyword">case</span> !<span class="hljs-keyword">this</span>.isString():
      <span class="hljs-keyword">return</span> <span class="hljs-string">'string'</span>;
    <span class="hljs-keyword">case</span> !<span class="hljs-keyword">this</span>.isRegex():
      <span class="hljs-keyword">return</span> <span class="hljs-string">'regex'</span>;
    <span class="hljs-keyword">case</span> !<span class="hljs-keyword">this</span>.isComplex():
      <span class="hljs-keyword">return</span> <span class="hljs-string">'complex'</span>;
    }
  };
  prototype.varName = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^\w+$/</span>.test(<span class="hljs-keyword">this</span>.value)) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">'$'</span> + <span class="hljs-keyword">this</span>.value;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
    }
  };
  prototype.makeReturn = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">if</span> (!it &amp;&amp; <span class="hljs-keyword">this</span>.value === <span class="hljs-string">'debugger'</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> superclass.prototype.makeReturn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }
  };
  prototype.compile = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, level)</span>{</span>
    <span class="hljs-keyword">var</span> val, ref$;
    level == <span class="hljs-literal">null</span> &amp;&amp; (level = o.level);
    <span class="hljs-keyword">switch</span> (val = <span class="hljs-keyword">this</span>.value + <span class="hljs-string">""</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'this'</span>:
      <span class="hljs-keyword">return</span> ((ref$ = o.scope.fun) != <span class="hljs-literal">null</span> ? ref$.bound : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>) || val;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'void'</span>:
      <span class="hljs-keyword">if</span> (!level) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
      }
      val += <span class="hljs-string">' 8'</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>fallthrough</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">case</span> <span class="hljs-string">'null'</span>:
      <span class="hljs-keyword">if</span> (level === LEVEL_CALL) {
        <span class="hljs-keyword">this</span>.carp(<span class="hljs-string">'invalid use of '</span> + <span class="hljs-keyword">this</span>.value);
      }
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'on'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'yes'</span>:
      val = <span class="hljs-string">'true'</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'off'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'no'</span>:
      val = <span class="hljs-string">'false'</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:
      <span class="hljs-keyword">this</span>.carp(<span class="hljs-string">'stray star'</span>);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'..'</span>:
      <span class="hljs-keyword">if</span> (!(val = o.ref)) {
        <span class="hljs-keyword">this</span>.carp(<span class="hljs-string">'stray reference'</span>);
      }
      <span class="hljs-keyword">this</span>.cascadee || (val.erred = <span class="hljs-literal">true</span>);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'debugger'</span>:
      <span class="hljs-keyword">if</span> (level) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"(function(){ debugger; }())"</span>;
      }
    }
    <span class="hljs-keyword">return</span> val;
  };
  <span class="hljs-keyword">return</span> Literal;
}(Atom));
exports.Var = Var = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Var, superclass).displayName = <span class="hljs-string">'Var'</span>, Var), superclass).prototype, constructor = Var;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Var</span><span class="hljs-params">(value)</span>{</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">this</span>$.value = value;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.isAssignable = prototype.isCallable = YES;
  prototype.assigns = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">return</span> it === <span class="hljs-keyword">this</span>.value;
  };
  prototype.maybeKey = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> ref$;
    <span class="hljs-keyword">return</span> ref$ = Key(<span class="hljs-keyword">this</span>.value), ref$.line = <span class="hljs-keyword">this</span>.line, ref$;
  };
  prototype.varName = prototype.show;
  prototype.compile = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.temp) {
      <span class="hljs-keyword">return</span> o.scope.free(<span class="hljs-keyword">this</span>.value);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value;
    }
  };
  <span class="hljs-keyword">return</span> Var;
}(Atom));
exports.Key = Key = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Key, superclass).displayName = <span class="hljs-string">'Key'</span>, Key), superclass).prototype, constructor = Key;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Key</span><span class="hljs-params">(name, reserved)</span>{</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">this</span>$.reserved = reserved || name.reserved;
    <span class="hljs-keyword">this</span>$.name = <span class="hljs-string">''</span> + name;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.isComplex = NO;
  prototype.assigns = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">return</span> it === <span class="hljs-keyword">this</span>.name;
  };
  prototype.varName = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> name;
    name = <span class="hljs-keyword">this</span>.name;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.reserved || (name === <span class="hljs-string">'arguments'</span> || name === <span class="hljs-string">'eval'</span>)) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"$"</span> + name;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> name;
    }
  };
  prototype.compile = prototype.show = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.reserved) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"'"</span> + <span class="hljs-keyword">this</span>.name + <span class="hljs-string">"'"</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;
    }
  };
  <span class="hljs-keyword">return</span> Key;
}(Node));
exports.Index = Index = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Index, superclass).displayName = <span class="hljs-string">'Index'</span>, Index), superclass).prototype, constructor = Index;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Index</span><span class="hljs-params">(key, symbol, init)</span>{</span>
    <span class="hljs-keyword">var</span> k, <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    symbol || (symbol = <span class="hljs-string">'.'</span>);
    <span class="hljs-keyword">if</span> (init &amp;&amp; key <span class="hljs-keyword">instanceof</span> Arr) {
      <span class="hljs-keyword">switch</span> (key.items.length) {
      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
        <span class="hljs-keyword">if</span> (!((k = key.items[<span class="hljs-number">0</span>]) <span class="hljs-keyword">instanceof</span> Splat)) {
          key = Parens(k);
        }
      }
    }
    <span class="hljs-keyword">switch</span> (symbol) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'[]'</span>:
      <span class="hljs-keyword">this</span>$.vivify = Arr;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'{}'</span>:
      <span class="hljs-keyword">this</span>$.vivify = Obj;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">if</span> (<span class="hljs-string">'='</span> === symbol.slice(-<span class="hljs-number">1</span>)) {
        <span class="hljs-keyword">this</span>$.assign = symbol.slice(<span class="hljs-number">1</span>);
      }
    }
    <span class="hljs-keyword">this</span>$.key = key;
    <span class="hljs-keyword">this</span>$.symbol = symbol;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.children = [<span class="hljs-string">'key'</span>];
  prototype.show = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">this</span>.soak ? <span class="hljs-string">'?'</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>] + <span class="hljs-keyword">this</span>.symbol;
  };
  prototype.isComplex = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.key.isComplex();
  };
  prototype.varName = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> ref$;
    <span class="hljs-keyword">return</span> ((ref$ = <span class="hljs-keyword">this</span>.key) <span class="hljs-keyword">instanceof</span> Key || ref$ <span class="hljs-keyword">instanceof</span> Literal) &amp;&amp; <span class="hljs-keyword">this</span>.key.varName();
  };
  prototype.compile = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> code;
    code = <span class="hljs-keyword">this</span>.key.compile(o, LEVEL_PAREN);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.key <span class="hljs-keyword">instanceof</span> Key &amp;&amp; <span class="hljs-string">'\''</span> !== code.charAt(<span class="hljs-number">0</span>)) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"."</span> + code;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"["</span> + code + <span class="hljs-string">"]"</span>;
    }
  };
  <span class="hljs-keyword">return</span> Index;
}(Node));
exports.Slice = Slice = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Slice, superclass).displayName = <span class="hljs-string">'Slice'</span>, Slice), superclass).prototype, constructor = Slice;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Slice</span><span class="hljs-params">(arg$)</span>{</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">this</span>$.type = arg$.type, <span class="hljs-keyword">this</span>$.target = arg$.target, <span class="hljs-keyword">this</span>$.from = arg$.from, <span class="hljs-keyword">this</span>$.to = arg$.to;
    <span class="hljs-keyword">this</span>$.from == <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">this</span>$.from = Literal(<span class="hljs-number">0</span>));
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>$.to &amp;&amp; <span class="hljs-keyword">this</span>$.type === <span class="hljs-string">'to'</span>) {
      <span class="hljs-keyword">this</span>$.to = Binary(<span class="hljs-string">'+'</span>, <span class="hljs-keyword">this</span>$.to, Literal(<span class="hljs-string">'1'</span>));
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.children = [<span class="hljs-string">'target'</span>, <span class="hljs-string">'from'</span>, <span class="hljs-string">'to'</span>];
  prototype.show = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.type;
  };
  prototype.compileNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> args;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.to &amp;&amp; <span class="hljs-keyword">this</span>.type === <span class="hljs-string">'to'</span>) {
      <span class="hljs-keyword">this</span>.to = Binary(<span class="hljs-string">'||'</span>, <span class="hljs-keyword">this</span>.to, Literal(<span class="hljs-string">'9e9'</span>));
    }
    args = [<span class="hljs-keyword">this</span>.target, <span class="hljs-keyword">this</span>.from];
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.to) {
      args.push(<span class="hljs-keyword">this</span>.to);
    }
    <span class="hljs-keyword">return</span> Chain(Var(util(<span class="hljs-string">'slice'</span>))).add(Index(Key(<span class="hljs-string">'call'</span>), <span class="hljs-string">'.'</span>, <span class="hljs-literal">true</span>)).add(Call(args)).compile(o);
  };
  <span class="hljs-keyword">return</span> Slice;
}(Node));
exports.Chain = Chain = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Chain, superclass).displayName = <span class="hljs-string">'Chain'</span>, Chain), superclass).prototype, constructor = Chain;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Chain</span><span class="hljs-params">(head, tails)</span>{</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">if</span> (!tails &amp;&amp; head <span class="hljs-keyword">instanceof</span> Chain) {
      <span class="hljs-keyword">return</span> head;
    }
    <span class="hljs-keyword">this</span>$.head = head;
    <span class="hljs-keyword">this</span>$.tails = tails || [];
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.children = [<span class="hljs-string">'head'</span>, <span class="hljs-string">'tails'</span>];
  prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">var</span> last, ref$, index, ref1$, bi, that, ref2$, logics, call, f;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tails.length) {
      last = (ref$ = <span class="hljs-keyword">this</span>.tails)[ref$.length - <span class="hljs-number">1</span>];
      <span class="hljs-keyword">if</span> (last <span class="hljs-keyword">instanceof</span> Call &amp;&amp; ((ref$ = last.partialized) != <span class="hljs-literal">null</span> ? ref$.length : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>) === <span class="hljs-number">1</span> &amp;&amp; it.args.length === <span class="hljs-number">1</span>) {
        index = last.partialized[<span class="hljs-number">0</span>].head.value;
        <span class="hljs-keyword">delete</span> last.partialized;
        last.args[index] = it.args[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      }
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.head <span class="hljs-keyword">instanceof</span> Existence) {
      ref1$ = Chain(<span class="hljs-keyword">this</span>.head.it), <span class="hljs-keyword">this</span>.head = ref1$.head, <span class="hljs-keyword">this</span>.tails = ref1$.tails;
      it.soak = <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">this</span>.tails.push(it);
    bi = <span class="hljs-keyword">this</span>.head <span class="hljs-keyword">instanceof</span> Parens &amp;&amp; <span class="hljs-keyword">this</span>.head.it <span class="hljs-keyword">instanceof</span> Binary &amp;&amp; !<span class="hljs-keyword">this</span>.head.it.partial
      ? <span class="hljs-keyword">this</span>.head.it
      : <span class="hljs-keyword">this</span>.head <span class="hljs-keyword">instanceof</span> Binary &amp;&amp; !<span class="hljs-keyword">this</span>.head.partial ? <span class="hljs-keyword">this</span>.head : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.head <span class="hljs-keyword">instanceof</span> Super) {
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.head.called &amp;&amp; it <span class="hljs-keyword">instanceof</span> Call &amp;&amp; !it.method) {
        it.method = <span class="hljs-string">'.call'</span>;
        it.args.unshift(Literal(<span class="hljs-string">'this'</span>));
        <span class="hljs-keyword">this</span>.head.called = <span class="hljs-literal">true</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.tails[<span class="hljs-number">1</span>] &amp;&amp; ((ref1$ = it.key) != <span class="hljs-literal">null</span> ? ref1$.name : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>) === <span class="hljs-string">'prototype'</span>) {
        <span class="hljs-keyword">this</span>.head.sproto = <span class="hljs-literal">true</span>;
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (that = (ref2$ = it.vivify, <span class="hljs-keyword">delete</span> it.vivify, ref2$)) {
      <span class="hljs-keyword">this</span>.head = Assign(Chain(<span class="hljs-keyword">this</span>.head, <span class="hljs-keyword">this</span>.tails.splice(<span class="hljs-number">0</span>, <span class="hljs-number">9e9</span>)), that(), <span class="hljs-string">'='</span>, <span class="hljs-string">'||'</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (it <span class="hljs-keyword">instanceof</span> Call &amp;&amp; <span class="hljs-keyword">this</span>.tails.length === <span class="hljs-number">1</span> &amp;&amp; bi &amp;&amp; <span class="hljs-keyword">in</span>$(bi.op, logics = [<span class="hljs-string">'&amp;&amp;'</span>, <span class="hljs-string">'||'</span>, <span class="hljs-string">'xor'</span>])) {
      call = it;
      f = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x, key)</span>{</span>
        <span class="hljs-keyword">var</span> y;
        y = x[key];
        <span class="hljs-keyword">if</span> (y <span class="hljs-keyword">instanceof</span> Binary &amp;&amp; <span class="hljs-keyword">in</span>$(y.op, logics)) {
          f(y, <span class="hljs-string">'first'</span>);
          <span class="hljs-keyword">return</span> f(y, <span class="hljs-string">'second'</span>);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> x[key] = Chain(y).autoCompare(call.args);
        }
      };
      f(bi, <span class="hljs-string">'first'</span>);
      f(bi, <span class="hljs-string">'second'</span>);
      <span class="hljs-keyword">return</span> bi;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  prototype.autoCompare = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(target)</span>{</span>
    <span class="hljs-keyword">var</span> test;
    test = <span class="hljs-keyword">this</span>.head;
    <span class="hljs-keyword">switch</span> (<span class="hljs-literal">false</span>) {
    <span class="hljs-keyword">case</span> !(test <span class="hljs-keyword">instanceof</span> Literal):
      <span class="hljs-keyword">return</span> Binary(<span class="hljs-string">'==='</span>, test, target[<span class="hljs-number">0</span>]);
    <span class="hljs-keyword">case</span> !(test <span class="hljs-keyword">instanceof</span> Unary &amp;&amp; test.it <span class="hljs-keyword">instanceof</span> Literal):
      <span class="hljs-keyword">return</span> Binary(<span class="hljs-string">'==='</span>, test, target[<span class="hljs-number">0</span>]);
    <span class="hljs-keyword">case</span> !(test <span class="hljs-keyword">instanceof</span> Arr || test <span class="hljs-keyword">instanceof</span> Obj):
      <span class="hljs-keyword">return</span> Binary(<span class="hljs-string">'===='</span>, test, target[<span class="hljs-number">0</span>]);
    <span class="hljs-keyword">case</span> !(test <span class="hljs-keyword">instanceof</span> Var &amp;&amp; test.value === <span class="hljs-string">'_'</span>):
      <span class="hljs-keyword">return</span> Literal(<span class="hljs-string">'true'</span>);
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.add(Call(target)) || [];
    }
  };
  prototype.flipIt = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">this</span>.flip = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  prototype.unwrap = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tails.length) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.head;
    }
  };
  prototype.delegate([<span class="hljs-string">'getJump'</span>, <span class="hljs-string">'assigns'</span>, <span class="hljs-string">'isStatement'</span>, <span class="hljs-string">'isString'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it, arg)</span>{</span>
    <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.tails.length &amp;&amp; <span class="hljs-keyword">this</span>.head[it](arg);
  });
  prototype.isComplex = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.tails.length || <span class="hljs-keyword">this</span>.head.isComplex();
  };
  prototype.isCallable = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> that, ref$;
    <span class="hljs-keyword">if</span> (that = (ref$ = <span class="hljs-keyword">this</span>.tails)[ref$.length - <span class="hljs-number">1</span>]) {
      <span class="hljs-keyword">return</span> !((ref$ = that.key) != <span class="hljs-literal">null</span> &amp;&amp; ref$.items);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.head.isCallable();
    }
  };
  prototype.isArray = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> that, ref$;
    <span class="hljs-keyword">if</span> (that = (ref$ = <span class="hljs-keyword">this</span>.tails)[ref$.length - <span class="hljs-number">1</span>]) {
      <span class="hljs-keyword">return</span> that.key <span class="hljs-keyword">instanceof</span> Arr;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.head.isArray();
    }
  };
  prototype.isRegex = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.head.value === <span class="hljs-string">'RegExp'</span> &amp;&amp; !<span class="hljs-keyword">this</span>.tails[<span class="hljs-number">1</span>] &amp;&amp; <span class="hljs-keyword">this</span>.tails[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> Call;
  };
  prototype.isAssignable = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> tail, ref$, i$, len$;
    <span class="hljs-keyword">if</span> (!(tail = (ref$ = <span class="hljs-keyword">this</span>.tails)[ref$.length - <span class="hljs-number">1</span>])) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.head.isAssignable();
    }
    <span class="hljs-keyword">if</span> (!(tail <span class="hljs-keyword">instanceof</span> Index) || tail.key <span class="hljs-keyword">instanceof</span> List || tail.symbol === <span class="hljs-string">'.~'</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = <span class="hljs-keyword">this</span>.tails).length; i$ &lt; len$; ++i$) {
      tail = ref$[i$];
      <span class="hljs-keyword">if</span> (tail.assign) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  };
  prototype.isSimpleAccess = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.tails.length === <span class="hljs-number">1</span> &amp;&amp; !<span class="hljs-keyword">this</span>.head.isComplex() &amp;&amp; !<span class="hljs-keyword">this</span>.tails[<span class="hljs-number">0</span>].isComplex();
  };
  prototype.makeReturn = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tails.length) {
      <span class="hljs-keyword">return</span> superclass.prototype.makeReturn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.head.makeReturn(it);
    }
  };
  prototype.getCall = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> tail, ref$;
    <span class="hljs-keyword">return</span> (tail = (ref$ = <span class="hljs-keyword">this</span>.tails)[ref$.length - <span class="hljs-number">1</span>]) <span class="hljs-keyword">instanceof</span> Call &amp;&amp; tail;
  };
  prototype.varName = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> ref$, ref1$;
    <span class="hljs-keyword">return</span> (ref$ = (ref1$ = <span class="hljs-keyword">this</span>.tails)[ref1$.length - <span class="hljs-number">1</span>]) != <span class="hljs-literal">null</span> ? ref$.varName() : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>;
  };
  prototype.cacheReference = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> name, ref$, base, ref, bref, nref;
    name = (ref$ = <span class="hljs-keyword">this</span>.tails)[ref$.length - <span class="hljs-number">1</span>];
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isAssignable()) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.unwrap().cache(o, <span class="hljs-literal">true</span>);
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tails.length &lt; <span class="hljs-number">2</span> &amp;&amp; !<span class="hljs-keyword">this</span>.head.isComplex() &amp;&amp; !(name != <span class="hljs-literal">null</span> &amp;&amp; name.isComplex())) {
      <span class="hljs-keyword">return</span> [<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>];
    }
    base = Chain(<span class="hljs-keyword">this</span>.head, <span class="hljs-keyword">this</span>.tails.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>));
    <span class="hljs-keyword">if</span> (base.isComplex()) {
      ref = o.scope.temporary();
      base = Chain(Assign(Var(ref), base));
      bref = (ref$ = Var(ref), ref$.temp = <span class="hljs-literal">true</span>, ref$);
    }
    <span class="hljs-keyword">if</span> (!name) {
      <span class="hljs-keyword">return</span> [base, bref];
    }
    <span class="hljs-keyword">if</span> (name.isComplex()) {
      ref = o.scope.temporary(<span class="hljs-string">'key'</span>);
      name = Index(Assign(Var(ref), name.key));
      nref = Index((ref$ = Var(ref), ref$.temp = <span class="hljs-literal">true</span>, ref$));
    }
    <span class="hljs-keyword">return</span> [base.add(name), Chain(bref || base.head, [nref || name])];
  };
  prototype.compileNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> head, tails, that, i$, len$, t, hasPartial, pre, rest, broken, partial, post, context, idt, func, base, news, ref$;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.flip) {
      util(<span class="hljs-string">'flip'</span>);
      util(<span class="hljs-string">'curry'</span>);
    }
    head = <span class="hljs-keyword">this</span>.head, tails = <span class="hljs-keyword">this</span>.tails;
    head.front = <span class="hljs-keyword">this</span>.front;
    head.newed = <span class="hljs-keyword">this</span>.newed;
    <span class="hljs-keyword">if</span> (!tails.length) {
      <span class="hljs-keyword">return</span> head.compile(o);
    }
    <span class="hljs-keyword">if</span> (that = <span class="hljs-keyword">this</span>.unfoldAssign(o)) {
      <span class="hljs-keyword">return</span> that.compile(o);
    }
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = tails.length; i$ &lt; len$; ++i$) {
      t = tails[i$];
      <span class="hljs-keyword">if</span> (t.partialized) {
        hasPartial = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">break</span>;
      }
    }
    <span class="hljs-keyword">if</span> (hasPartial) {
      util(<span class="hljs-string">'slice'</span>);
      pre = [];
      rest = [];
      <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = tails.length; i$ &lt; len$; ++i$) {
        t = tails[i$];
        broken = broken || t.partialized != <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">if</span> (broken) {
          rest.push(t);
        } <span class="hljs-keyword">else</span> {
          pre.push(t);
        }
      }
      <span class="hljs-keyword">if</span> (rest != <span class="hljs-literal">null</span>) {
        partial = rest[<span class="hljs-number">0</span>], post = slice$.call(rest, <span class="hljs-number">1</span>);
      }
      <span class="hljs-keyword">this</span>.tails = pre;
      context = pre.length
        ? Chain(head, slice$.call(pre, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>))
        : Literal(<span class="hljs-string">'this'</span>);
      <span class="hljs-keyword">return</span> Chain(Chain(Var(util(<span class="hljs-string">'partialize'</span>))).add(Index(Key(<span class="hljs-string">'apply'</span>))).add(Call([context, Arr([<span class="hljs-keyword">this</span>, Arr(partial.args), Arr(partial.partialized)])])), post).compile(o);
    }
    <span class="hljs-keyword">if</span> (tails[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> Call &amp;&amp; !head.isCallable()) {
      <span class="hljs-keyword">this</span>.carp(<span class="hljs-string">'invalid callee'</span>);
    }
    <span class="hljs-keyword">this</span>.expandSlice(o);
    <span class="hljs-keyword">this</span>.expandBind(o);
    <span class="hljs-keyword">this</span>.expandSplat(o);
    <span class="hljs-keyword">this</span>.expandStar(o);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.splattedNewArgs) {
      idt = o.indent + TAB;
      func = Chain(<span class="hljs-keyword">this</span>.head, tails.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>));
      <span class="hljs-keyword">return</span> <span class="hljs-string">"(function(func, args, ctor) {\n"</span> + idt + <span class="hljs-string">"ctor.prototype = func.prototype;\n"</span> + idt + <span class="hljs-string">"var child = new ctor, result = func.apply(child, args), t;\n"</span> + idt + <span class="hljs-string">"return (t = typeof result)  == \"object\" || t == \"function\" ? result || child : child;\n"</span> + TAB + <span class="hljs-string">"})("</span> + func.compile(o) + <span class="hljs-string">", "</span> + <span class="hljs-keyword">this</span>.splattedNewArgs + <span class="hljs-string">", function(){})"</span>;
    }
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.tails.length) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.head.compile(o);
    }
    base = <span class="hljs-keyword">this</span>.head.compile(o, LEVEL_CALL);
    news = rest = <span class="hljs-string">''</span>;
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = <span class="hljs-keyword">this</span>.tails).length; i$ &lt; len$; ++i$) {
      t = ref$[i$];
      <span class="hljs-keyword">if</span> (t[<span class="hljs-string">'new'</span>]) {
        news += <span class="hljs-string">'new '</span>;
      }
      rest += t.compile(o);
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-string">'.'</span> === rest.charAt(<span class="hljs-number">0</span>) &amp;&amp; SIMPLENUM.test(base)) {
      base += <span class="hljs-string">' '</span>;
    }
    <span class="hljs-keyword">return</span> news + base + rest;
  };
  prototype.unfoldSoak = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> that, ref$, i$, len$, i, node, ref1$, bust, test;
    <span class="hljs-keyword">if</span> (that = <span class="hljs-keyword">this</span>.head.unfoldSoak(o)) {
      (ref$ = that.then.tails).push.apply(ref$, <span class="hljs-keyword">this</span>.tails);
      <span class="hljs-keyword">return</span> that;
    }
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = <span class="hljs-keyword">this</span>.tails).length; i$ &lt; len$; ++i$) {
      i = i$;
      node = ref$[i$];
      <span class="hljs-keyword">if</span> (ref1$ = node.soak, <span class="hljs-keyword">delete</span> node.soak, ref1$) {
        bust = Chain(<span class="hljs-keyword">this</span>.head, <span class="hljs-keyword">this</span>.tails.splice(<span class="hljs-number">0</span>, i));
        <span class="hljs-keyword">if</span> (node.assign &amp;&amp; !bust.isAssignable()) {
          node.carp(<span class="hljs-string">'invalid accessign'</span>);
        }
        <span class="hljs-keyword">if</span> (i &amp;&amp; (node.assign || node <span class="hljs-keyword">instanceof</span> Call)) {
          ref1$ = bust.cacheReference(o), test = ref1$[<span class="hljs-number">0</span>], bust = ref1$[<span class="hljs-number">1</span>];
          <span class="hljs-keyword">if</span> (bust <span class="hljs-keyword">instanceof</span> Chain) {
            (ref1$ = <span class="hljs-keyword">this</span>.tails).unshift.apply(ref1$, bust.tails);
            bust = bust.head;
          }
          <span class="hljs-keyword">this</span>.head = bust;
        } <span class="hljs-keyword">else</span> {
          ref1$ = bust.unwrap().cache(o), test = ref1$[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>.head = ref1$[<span class="hljs-number">1</span>];
        }
        test = node <span class="hljs-keyword">instanceof</span> Call
          ? JS(<span class="hljs-string">"typeof "</span> + test.compile(o, LEVEL_OP) + <span class="hljs-string">" == 'function'"</span>)
          : Existence(test);
        <span class="hljs-keyword">return</span> ref1$ = If(test, <span class="hljs-keyword">this</span>), ref1$.soak = <span class="hljs-literal">true</span>, ref1$.cond = <span class="hljs-keyword">this</span>.cond, ref1$[<span class="hljs-string">'void'</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'void'</span>], ref1$;
      }
    }
  };
  prototype.unfoldAssign = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> that, ref$, i$, len$, i, index, op, left, lefts, rites, j$, len1$, node, ref1$;
    <span class="hljs-keyword">if</span> (that = <span class="hljs-keyword">this</span>.head.unfoldAssign(o)) {
      (ref$ = that.right.tails).push.apply(ref$, <span class="hljs-keyword">this</span>.tails);
      <span class="hljs-keyword">return</span> that;
    }
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = <span class="hljs-keyword">this</span>.tails).length; i$ &lt; len$; ++i$) {
      i = i$;
      index = ref$[i$];
      <span class="hljs-keyword">if</span> (op = index.assign) {
        index.assign = <span class="hljs-string">''</span>;
        left = Chain(<span class="hljs-keyword">this</span>.head, <span class="hljs-keyword">this</span>.tails.splice(<span class="hljs-number">0</span>, i)).expandSlice(o).unwrap();
        <span class="hljs-keyword">if</span> (left <span class="hljs-keyword">instanceof</span> Arr) {
          lefts = left.items;
          rites = (<span class="hljs-keyword">this</span>.head = Arr()).items;
          <span class="hljs-keyword">for</span> (j$ = <span class="hljs-number">0</span>, len1$ = lefts.length; j$ &lt; len1$; ++j$) {
            i = j$;
            node = lefts[j$];
            ref1$ = Chain(node).cacheReference(o), rites[i] = ref1$[<span class="hljs-number">0</span>], lefts[i] = ref1$[<span class="hljs-number">1</span>];
          }
        } <span class="hljs-keyword">else</span> {
          ref1$ = Chain(left).cacheReference(o), left = ref1$[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>.head = ref1$[<span class="hljs-number">1</span>];
        }
        <span class="hljs-keyword">if</span> (op === <span class="hljs-string">'='</span>) {
          op = <span class="hljs-string">':='</span>;
        }
        <span class="hljs-keyword">return</span> ref1$ = Assign(left, <span class="hljs-keyword">this</span>, op), ref1$.access = <span class="hljs-literal">true</span>, ref1$;
      }
    }
  };
  prototype.expandSplat = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> tails, i, call, args, ctx, ref$;
    tails = <span class="hljs-keyword">this</span>.tails;
    i = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (call = tails[++i]) {
      <span class="hljs-keyword">if</span> (!(args = call.args)) {
        <span class="hljs-keyword">continue</span>;
      }
      ctx = call.method === <span class="hljs-string">'.call'</span> &amp;&amp; (args = args.concat()).shift();
      <span class="hljs-keyword">if</span> (!(args = Splat.compileArray(o, args, <span class="hljs-literal">true</span>))) {
        <span class="hljs-keyword">continue</span>;
      }
      <span class="hljs-keyword">if</span> (call[<span class="hljs-string">'new'</span>]) {
        <span class="hljs-keyword">this</span>.splattedNewArgs = args;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (!ctx &amp;&amp; tails[i - <span class="hljs-number">1</span>] <span class="hljs-keyword">instanceof</span> Index) {
          ref$ = Chain(<span class="hljs-keyword">this</span>.head, tails.splice(<span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>)).cache(o, <span class="hljs-literal">true</span>), <span class="hljs-keyword">this</span>.head = ref$[<span class="hljs-number">0</span>], ctx = ref$[<span class="hljs-number">1</span>];
          i = <span class="hljs-number">0</span>;
        }
        call.method = <span class="hljs-string">'.apply'</span>;
        call.args = [ctx || Literal(<span class="hljs-string">'null'</span>), JS(args)];
      }
    }
  };
  prototype.expandBind = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> tails, i, that, obj, key, call;
    tails = <span class="hljs-keyword">this</span>.tails;
    i = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (that = tails[++i]) {
      <span class="hljs-keyword">if</span> (that.symbol !== <span class="hljs-string">'.~'</span>) {
        <span class="hljs-keyword">continue</span>;
      }
      that.symbol = <span class="hljs-string">''</span>;
      obj = Chain(<span class="hljs-keyword">this</span>.head, tails.splice(<span class="hljs-number">0</span>, i)).unwrap();
      key = tails.shift().key;
      call = Call.make(Util(<span class="hljs-string">'bind'</span>), [obj, (key.reserved = <span class="hljs-literal">true</span>, key)]);
      <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">this</span>.newed ? Parens(call, <span class="hljs-literal">true</span>) : call;
      i = -<span class="hljs-number">1</span>;
    }
  };
  prototype.expandStar = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> tails, i, that, stars, ref$, sub, ref, temps, value, i$, len$, star;
    tails = <span class="hljs-keyword">this</span>.tails;
    i = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (that = tails[++i]) {
      <span class="hljs-keyword">if</span> (that.args || that.stars || that.key <span class="hljs-keyword">instanceof</span> Key) {
        <span class="hljs-keyword">continue</span>;
      }
      stars = that.stars = [];
      that.eachChild(seek);
      <span class="hljs-keyword">if</span> (!stars.length) {
        <span class="hljs-keyword">continue</span>;
      }
      ref$ = Chain(<span class="hljs-keyword">this</span>.head, tails.splice(<span class="hljs-number">0</span>, i)).unwrap().cache(o), sub = ref$[<span class="hljs-number">0</span>], ref = ref$[<span class="hljs-number">1</span>], temps = ref$[<span class="hljs-number">2</span>];
      value = Chain(ref, [Index(Key(<span class="hljs-string">'length'</span>))]).compile(o);
      <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = stars.length; i$ &lt; len$; ++i$) {
        star = stars[i$];
        star.value = value;
        star.isAssignable = YES;
      }
      <span class="hljs-keyword">this</span>.head = JS(sub.compile(o, LEVEL_CALL) + tails.shift().compile(o));
      <span class="hljs-keyword">if</span> (temps) {
        o.scope.free(temps[<span class="hljs-number">0</span>]);
      }
      i = -<span class="hljs-number">1</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">seek</span><span class="hljs-params">(it)</span>{</span>
      <span class="hljs-keyword">if</span> (it.value === <span class="hljs-string">'*'</span>) {
        stars.push(it);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(it <span class="hljs-keyword">instanceof</span> Index)) {
        it.eachChild(seek);
      }
    }
  };
  prototype.expandSlice = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, assign)</span>{</span>
    <span class="hljs-keyword">var</span> tails, i, tail, ref$, x;
    tails = <span class="hljs-keyword">this</span>.tails;
    i = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (tail = tails[++i]) {
      <span class="hljs-keyword">if</span> ((ref$ = tail.key) != <span class="hljs-literal">null</span> &amp;&amp; ref$.items) {
        <span class="hljs-keyword">if</span> (tails[i + <span class="hljs-number">1</span>] <span class="hljs-keyword">instanceof</span> Call) {
          tail.carp(<span class="hljs-string">'calling a slice'</span>);
        }
        x = tails.splice(<span class="hljs-number">0</span>, i + <span class="hljs-number">1</span>);
        x = x.pop().key.toSlice(o, Chain(<span class="hljs-keyword">this</span>.head, x).unwrap(), tail.symbol, assign);
        <span class="hljs-keyword">this</span>.head = (x.front = <span class="hljs-keyword">this</span>.front, x);
        i = -<span class="hljs-number">1</span>;
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  <span class="hljs-keyword">return</span> Chain;
}(Node));
exports.Call = Call = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Call, superclass).displayName = <span class="hljs-string">'Call'</span>, Call), superclass).prototype, constructor = Call;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Call</span><span class="hljs-params">(args)</span>{</span>
    <span class="hljs-keyword">var</span> splat, i$, len$, i, a, ref$, <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    args || (args = []);
    <span class="hljs-keyword">if</span> (args.length === <span class="hljs-number">1</span> &amp;&amp; (splat = args[<span class="hljs-number">0</span>]) <span class="hljs-keyword">instanceof</span> Splat) {
      <span class="hljs-keyword">if</span> (splat.filler) {
        <span class="hljs-keyword">this</span>$.method = <span class="hljs-string">'.call'</span>;
        args[<span class="hljs-number">0</span>] = Literal(<span class="hljs-string">'this'</span>);
        args[<span class="hljs-number">1</span>] = Splat(Literal(<span class="hljs-string">'arguments'</span>));
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (splat.it <span class="hljs-keyword">instanceof</span> Arr) {
        args = splat.it.items;
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = args.length; i$ &lt; len$; ++i$) {
        i = i$;
        a = args[i$];
        <span class="hljs-keyword">if</span> (a.value === <span class="hljs-string">'_'</span>) {
          args[i] = Chain(Literal(<span class="hljs-string">'void'</span>));
          args[i].placeholder = <span class="hljs-literal">true</span>;
          ((ref$ = <span class="hljs-keyword">this</span>$.partialized) != <span class="hljs-literal">null</span>
            ? ref$
            : <span class="hljs-keyword">this</span>$.partialized = []).push(Chain(Literal(i)));
        }
      }
    }
    <span class="hljs-keyword">this</span>$.args = args;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.children = [<span class="hljs-string">'args'</span>];
  prototype.show = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">this</span>[<span class="hljs-string">'new'</span>]] + [<span class="hljs-keyword">this</span>.method] + [<span class="hljs-keyword">this</span>.soak ? <span class="hljs-string">'?'</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>];
  };
  prototype.compile = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> code, i$, ref$, len$, i, a;
    code = (<span class="hljs-keyword">this</span>.method || <span class="hljs-string">''</span>) + <span class="hljs-string">'('</span> + (<span class="hljs-keyword">this</span>.pipe ? <span class="hljs-string">"\n"</span> + o.indent : <span class="hljs-string">''</span>);
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = <span class="hljs-keyword">this</span>.args).length; i$ &lt; len$; ++i$) {
      i = i$;
      a = ref$[i$];
      code += (i ? <span class="hljs-string">', '</span> : <span class="hljs-string">''</span>) + a.compile(o, LEVEL_LIST);
    }
    <span class="hljs-keyword">return</span> code + <span class="hljs-string">')'</span>;
  };
  Call.make = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callee, args, opts)</span>{</span>
    <span class="hljs-keyword">var</span> call;
    call = Call(args);
    <span class="hljs-keyword">if</span> (opts) {
      import$(call, opts);
    }
    <span class="hljs-keyword">return</span> Chain(callee).add(call);
  };
  Call.block = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fun, args, method)</span>{</span>
    <span class="hljs-keyword">var</span> ref$, ref1$;
    <span class="hljs-keyword">return</span> ref$ = Parens(Chain(fun, [(ref1$ = Call(args), ref1$.method = method, ref1$)]), <span class="hljs-literal">true</span>), ref$.calling = <span class="hljs-literal">true</span>, ref$;
  };
  Call.back = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(params, node, bound, curried)</span>{</span>
    <span class="hljs-keyword">var</span> fun, ref$, args, index, i$, len$, a;
    fun = Fun(params, <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>, bound, curried);
    <span class="hljs-keyword">if</span> (fun.hushed = node.op === <span class="hljs-string">'!'</span>) {
      node = node.it;
    }
    <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Label) {
      fun.name = node.label;
      fun.labeled = <span class="hljs-literal">true</span>;
      node = node.it;
    }
    <span class="hljs-keyword">if</span> (!fun.hushed &amp;&amp; (fun.hushed = node.op === <span class="hljs-string">'!'</span>)) {
      node = node.it;
    }
    <span class="hljs-keyword">if</span> ((ref$ = node.getCall()) != <span class="hljs-literal">null</span>) {
      ref$.partialized = <span class="hljs-literal">null</span>;
    }
    args = (node.getCall() || (node = Chain(node).add(Call())).getCall()).args;
    index = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = args.length; i$ &lt; len$; ++i$) {
      a = args[i$];
      <span class="hljs-keyword">if</span> (a.placeholder) {
        <span class="hljs-keyword">break</span>;
      }
      ++index;
    }
    <span class="hljs-keyword">return</span> node.back = (args[index] = fun).body, node;
  };
  Call[<span class="hljs-string">'let'</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(args, body)</span>{</span>
    <span class="hljs-keyword">var</span> params, res$, i$, len$, i, a, that, gotThis;
    res$ = [];
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = args.length; i$ &lt; len$; ++i$) {
      i = i$;
      a = args[i$];
      <span class="hljs-keyword">if</span> (that = a.op === <span class="hljs-string">'='</span> &amp;&amp; !a.logic &amp;&amp; a.right) {
        args[i] = that;
        <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span> &amp;&amp; (gotThis = a.left.value === <span class="hljs-string">'this'</span>)) {
          <span class="hljs-keyword">continue</span>;
        }
        res$.push(a.left);
      } <span class="hljs-keyword">else</span> {
        res$.push(Var(a.varName() || a.carp(<span class="hljs-string">'invalid "let" argument'</span>)));
      }
    }
    params = res$;
    gotThis || args.unshift(Literal(<span class="hljs-string">'this'</span>));
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.block(Fun(params, body), args, <span class="hljs-string">'.call'</span>);
  };
  <span class="hljs-keyword">return</span> Call;
}(Node));
List = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(List, superclass).displayName = <span class="hljs-string">'List'</span>, List), superclass).prototype, constructor = List;
  prototype.children = [<span class="hljs-string">'items'</span>];
  prototype.show = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;
  };
  prototype.named = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name)</span>{</span>
    <span class="hljs-keyword">this</span>.name = name;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  prototype.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.items.length;
  };
  prototype.assigns = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">var</span> i$, ref$, len$, node;
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = <span class="hljs-keyword">this</span>.items).length; i$ &lt; len$; ++i$) {
      node = ref$[i$];
      <span class="hljs-keyword">if</span> (node.assigns(it)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
    }
  };
  List.compile = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, items, deepEq)</span>{</span>
    <span class="hljs-keyword">var</span> indent, level, code, i, that, target;
    <span class="hljs-keyword">switch</span> (items.length) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
      <span class="hljs-keyword">return</span> items[<span class="hljs-number">0</span>].compile(o, LEVEL_LIST);
    }
    indent = o.indent, level = o.level;
    o.indent = indent + TAB;
    o.level = LEVEL_LIST;
    code = items[i = <span class="hljs-number">0</span>].compile(o);
    <span class="hljs-keyword">while</span> (that = items[++i]) {
      code += <span class="hljs-string">', '</span>;
      target = that;
      <span class="hljs-keyword">if</span> (deepEq) {
        <span class="hljs-keyword">if</span> (target <span class="hljs-keyword">instanceof</span> Var &amp;&amp; target.value === <span class="hljs-string">'_'</span>) {
          target = Obj([Prop(Key(<span class="hljs-string">'__placeholder__'</span>), Literal(<span class="hljs-literal">true</span>))]);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target <span class="hljs-keyword">instanceof</span> Obj || target <span class="hljs-keyword">instanceof</span> Arr) {
          target.deepEq = <span class="hljs-literal">true</span>;
        }
      }
      code += target.compile(o);
    }
    <span class="hljs-keyword">if</span> (~code.indexOf(<span class="hljs-string">'\n'</span>)) {
      code = <span class="hljs-string">"\n"</span> + o.indent + code + <span class="hljs-string">"\n"</span> + indent;
    }
    o.indent = indent;
    o.level = level;
    <span class="hljs-keyword">return</span> code;
  };
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">List</span><span class="hljs-params">()</span>{</span>
    List.superclass.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
  }
  <span class="hljs-keyword">return</span> List;
}(Node));
exports.Obj = Obj = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Obj, superclass).displayName = <span class="hljs-string">'Obj'</span>, Obj), superclass).prototype, constructor = Obj;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Obj</span><span class="hljs-params">(items)</span>{</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">this</span>$.items = items || [];
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.asObj = THIS;
  prototype.toSlice = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, base, symbol, assign)</span>{</span>
    <span class="hljs-keyword">var</span> items, ref$, ref, temps, i$, len$, i, node, name, chain, logic, key, val;
    items = <span class="hljs-keyword">this</span>.items;
    <span class="hljs-keyword">if</span> (items.length &gt; <span class="hljs-number">1</span>) {
      ref$ = base.cache(o), base = ref$[<span class="hljs-number">0</span>], ref = ref$[<span class="hljs-number">1</span>], temps = ref$[<span class="hljs-number">2</span>];
    } <span class="hljs-keyword">else</span> {
      ref = base;
    }
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = items.length; i$ &lt; len$; ++i$) {
      i = i$;
      node = items[i$];
      <span class="hljs-keyword">if</span> (node.comment) {
        <span class="hljs-keyword">continue</span>;
      }
      <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Prop || node <span class="hljs-keyword">instanceof</span> Splat) {
        node[name = (ref$ = node.children)[ref$.length - <span class="hljs-number">1</span>]] = chain = Chain(base, [Index(node[name].maybeKey())]);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (logic = node.getDefault()) {
          node = node.first;
        }
        <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Parens) {
          ref$ = node.cache(o, <span class="hljs-literal">true</span>), key = ref$[<span class="hljs-number">0</span>], node = ref$[<span class="hljs-number">1</span>];
          <span class="hljs-keyword">if</span> (assign) {
            ref$ = [node, key], key = ref$[<span class="hljs-number">0</span>], node = ref$[<span class="hljs-number">1</span>];
          }
          key = Parens(key);
        } <span class="hljs-keyword">else</span> {
          key = node;
        }
        val = chain = Chain(base, [Index(node.maybeKey(), symbol)]);
        <span class="hljs-keyword">if</span> (logic) {
          val = (logic.first = val, logic);
        }
        items[i] = Prop(key, val);
      }
      base = ref;
    }
    chain || <span class="hljs-keyword">this</span>.carp(<span class="hljs-string">'empty slice'</span>);
    <span class="hljs-keyword">if</span> (temps) {
      (chain.head = Var(temps[<span class="hljs-number">0</span>])).temp = <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  prototype.compileNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> items, code, idt, dic, i$, len$, i, node, logic, rest, ref$, multi, key, val;
    items = <span class="hljs-keyword">this</span>.items;
    <span class="hljs-keyword">if</span> (!items.length) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.front ? <span class="hljs-string">'({})'</span> : <span class="hljs-string">'{}'</span>;
    }
    code = <span class="hljs-string">''</span>;
    idt = <span class="hljs-string">'\n'</span> + (o.indent += TAB);
    dic = {};
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = items.length; i$ &lt; len$; ++i$) {
      i = i$;
      node = items[i$];
      <span class="hljs-keyword">if</span> (node.comment) {
        code += idt + node.compile(o);
        <span class="hljs-keyword">continue</span>;
      }
      <span class="hljs-keyword">if</span> (logic = node.getDefault()) {
        node = node.first;
      }
      <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Splat || (node.key || node) <span class="hljs-keyword">instanceof</span> Parens) {
        rest = items.slice(i);
        <span class="hljs-keyword">break</span>;
      }
      <span class="hljs-keyword">if</span> (logic) {
        <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Prop) {
          node.val = (logic.first = node.val, logic);
        } <span class="hljs-keyword">else</span> {
          node = Prop(node, (logic.first = node, logic));
        }
      }
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.deepEq &amp;&amp; node <span class="hljs-keyword">instanceof</span> Prop) {
        <span class="hljs-keyword">if</span> (node.val <span class="hljs-keyword">instanceof</span> Var &amp;&amp; node.val.value === <span class="hljs-string">'_'</span>) {
          node.val = Obj([Prop(Key(<span class="hljs-string">'__placeholder__'</span>), Literal(<span class="hljs-literal">true</span>))]);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((ref$ = node.val) <span class="hljs-keyword">instanceof</span> Obj || ref$ <span class="hljs-keyword">instanceof</span> Arr) {
          node.val.deepEq = <span class="hljs-literal">true</span>;
        }
      }
      <span class="hljs-keyword">if</span> (multi) {
        code += <span class="hljs-string">','</span>;
      } <span class="hljs-keyword">else</span> {
        multi = <span class="hljs-literal">true</span>;
      }
      code += idt + (node <span class="hljs-keyword">instanceof</span> Prop
        ? (key = node.key, val = node.val, node.accessor
          ? node.compileAccessor(o, key = key.compile(o))
          : (val.ripName(key), (key = key.compile(o)) + <span class="hljs-string">": "</span> + val.compile(o, LEVEL_LIST)))
        : (key = node.compile(o)) + <span class="hljs-string">": "</span> + key);
      ID.test(key) || (key = <span class="hljs-built_in">Function</span>(<span class="hljs-string">"return "</span> + key)());
      <span class="hljs-keyword">if</span> (!(dic[key + <span class="hljs-string">"."</span>] ^= <span class="hljs-number">1</span>)) {
        node.carp(<span class="hljs-string">"duplicate property \""</span> + key + <span class="hljs-string">"\""</span>);
      }
    }
    code = <span class="hljs-string">"{"</span> + (code &amp;&amp; code + <span class="hljs-string">'\n'</span> + <span class="hljs-keyword">this</span>.tab) + <span class="hljs-string">"}"</span>;
    rest &amp;&amp; (code = Import(JS(code), Obj(rest)).compile((o.indent = <span class="hljs-keyword">this</span>.tab, o)));
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.front &amp;&amp; <span class="hljs-string">'{'</span> === code.charAt()) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"("</span> + code + <span class="hljs-string">")"</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> code;
    }
  };
  <span class="hljs-keyword">return</span> Obj;
}(List));
exports.Prop = Prop = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Prop, superclass).displayName = <span class="hljs-string">'Prop'</span>, Prop), superclass).prototype, constructor = Prop;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Prop</span><span class="hljs-params">(key, val)</span>{</span>
    <span class="hljs-keyword">var</span> that, i$, len$, fun, <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">this</span>$.key = key;
    <span class="hljs-keyword">this</span>$.val = val;
    <span class="hljs-keyword">if</span> (key.value === <span class="hljs-string">'...'</span>) {
      <span class="hljs-keyword">return</span> Splat(<span class="hljs-keyword">this</span>$.val);
    }
    <span class="hljs-keyword">if</span> (that = val.getAccessors()) {
      <span class="hljs-keyword">this</span>$.val = that;
      <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = that.length; i$ &lt; len$; ++i$) {
        fun = that[i$];
        fun.x = (fun.hushed = fun.params.length) ? <span class="hljs-string">'s'</span> : <span class="hljs-string">'g'</span>;
      }
      <span class="hljs-keyword">this</span>$[<span class="hljs-string">'accessor'</span>] = <span class="hljs-string">'accessor'</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.children = [<span class="hljs-string">'key'</span>, <span class="hljs-string">'val'</span>];
  prototype.show = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.accessor;
  };
  prototype.assigns = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">var</span> ref$;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> (ref$ = <span class="hljs-keyword">this</span>.val).assigns == <span class="hljs-string">'function'</span> ? ref$.assigns(it) : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>;
  };
  prototype.compileAccessor = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, key)</span>{</span>
    <span class="hljs-keyword">var</span> funs, fun;
    funs = <span class="hljs-keyword">this</span>.val;
    <span class="hljs-keyword">if</span> (funs[<span class="hljs-number">1</span>] &amp;&amp; funs[<span class="hljs-number">0</span>].params.length + funs[<span class="hljs-number">1</span>].params.length !== <span class="hljs-number">1</span>) {
      funs[<span class="hljs-number">0</span>].carp(<span class="hljs-string">'invalid accessor parameter'</span>);
    }
    <span class="hljs-keyword">return</span> (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
      <span class="hljs-keyword">var</span> i$, ref$, len$, results$ = [];
      <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = funs).length; i$ &lt; len$; ++i$) {
        fun = ref$[i$];
        fun.accessor = <span class="hljs-literal">true</span>;
        results$.push(fun.x + <span class="hljs-string">"et "</span> + key + fun.compile(o, LEVEL_LIST).slice(<span class="hljs-number">8</span>));
      }
      <span class="hljs-keyword">return</span> results$;
    }()).join(<span class="hljs-string">',\n'</span> + o.indent);
  };
  prototype.compileDescriptor = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> obj, i$, ref$, len$, fun;
    obj = Obj();
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = <span class="hljs-keyword">this</span>.val).length; i$ &lt; len$; ++i$) {
      fun = ref$[i$];
      obj.items.push(Prop(Key(fun.x + <span class="hljs-string">'et'</span>), fun));
    }
    obj.items.push(Prop(Key(<span class="hljs-string">'configurable'</span>), Literal(<span class="hljs-literal">true</span>)));
    obj.items.push(Prop(Key(<span class="hljs-string">'enumerable'</span>), Literal(<span class="hljs-literal">true</span>)));
    <span class="hljs-keyword">return</span> obj.compile(o);
  };
  <span class="hljs-keyword">return</span> Prop;
}(Node));
exports.Arr = Arr = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Arr, superclass).displayName = <span class="hljs-string">'Arr'</span>, Arr), superclass).prototype, constructor = Arr;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Arr</span><span class="hljs-params">(items)</span>{</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">this</span>$.items = items || [];
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.isArray = YES;
  prototype.asObj = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> i, item;
    <span class="hljs-keyword">return</span> Obj((<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
      <span class="hljs-keyword">var</span> i$, ref$, len$, results$ = [];
      <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = <span class="hljs-keyword">this</span>.items).length; i$ &lt; len$; ++i$) {
        i = i$;
        item = ref$[i$];
        results$.push(Prop(Literal(i), item));
      }
      <span class="hljs-keyword">return</span> results$;
    }.call(<span class="hljs-keyword">this</span>)));
  };
  prototype.toSlice = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, base, symbol)</span>{</span>
    <span class="hljs-keyword">var</span> items, ref$, ref, i$, len$, i, item, splat, chain;
    items = <span class="hljs-keyword">this</span>.items;
    <span class="hljs-keyword">if</span> (items.length &gt; <span class="hljs-number">1</span>) {
      ref$ = base.cache(o), base = ref$[<span class="hljs-number">0</span>], ref = ref$[<span class="hljs-number">1</span>];
    } <span class="hljs-keyword">else</span> {
      ref = base;
    }
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = items.length; i$ &lt; len$; ++i$) {
      i = i$;
      item = items[i$];
      <span class="hljs-keyword">if</span> (splat = item <span class="hljs-keyword">instanceof</span> Splat) {
        item = item.it;
      }
      <span class="hljs-keyword">if</span> (item.isEmpty()) {
        <span class="hljs-keyword">continue</span>;
      }
      chain = Chain(base, [Index(item, symbol)]);
      items[i] = splat ? Splat(chain) : chain;
      base = ref;
    }
    chain || <span class="hljs-keyword">this</span>.carp(<span class="hljs-string">'empty slice'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  prototype.compile = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> items, code;
    items = <span class="hljs-keyword">this</span>.items;
    <span class="hljs-keyword">if</span> (!items.length) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">'[]'</span>;
    }
    <span class="hljs-keyword">if</span> (code = Splat.compileArray(o, items)) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.newed ? <span class="hljs-string">"("</span> + code + <span class="hljs-string">")"</span> : code;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-string">"["</span> + List.compile(o, items, <span class="hljs-keyword">this</span>.deepEq) + <span class="hljs-string">"]"</span>;
  };
  Arr.maybe = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(nodes)</span>{</span>
    <span class="hljs-keyword">if</span> (nodes.length === <span class="hljs-number">1</span> &amp;&amp; !(nodes[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> Splat)) {
      <span class="hljs-keyword">return</span> nodes[<span class="hljs-number">0</span>];
    }
    <span class="hljs-keyword">return</span> constructor(nodes);
  };
  Arr.wrap = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">return</span> constructor([Splat((it.isArray = YES, it))]);
  };
  <span class="hljs-keyword">return</span> Arr;
}(List));
exports.Unary = Unary = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Unary, superclass).displayName = <span class="hljs-string">'Unary'</span>, Unary), superclass).prototype, constructor = Unary;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Unary</span><span class="hljs-params">(op, it, flag)</span>{</span>
    <span class="hljs-keyword">var</span> that, i$, ref$, len$, node, <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">if</span> (it != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (that = !flag &amp;&amp; it.unaries) {
        that.push(op);
        <span class="hljs-keyword">return</span> it;
      }
      <span class="hljs-keyword">switch</span> (op) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'!'</span>:
        <span class="hljs-keyword">if</span> (flag) {
          <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">if</span> (it <span class="hljs-keyword">instanceof</span> Fun &amp;&amp; !it.hushed) {
          <span class="hljs-keyword">return</span> it.hushed = <span class="hljs-literal">true</span>, it;
        }
        <span class="hljs-keyword">return</span> it.invert();
      <span class="hljs-keyword">case</span> <span class="hljs-string">'++'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'--'</span>:
        <span class="hljs-keyword">if</span> (flag) {
          <span class="hljs-keyword">this</span>$.post = <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">'new'</span>:
        <span class="hljs-keyword">if</span> (it <span class="hljs-keyword">instanceof</span> Existence &amp;&amp; !it.negated) {
          it = Chain(it).add(Call());
        }
        it.newed = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = it.tails || <span class="hljs-string">''</span>).length; i$ &lt; len$; ++i$) {
          node = ref$[i$];
          <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Call &amp;&amp; !node[<span class="hljs-string">'new'</span>]) {
            <span class="hljs-keyword">if</span> (node.method === <span class="hljs-string">'.call'</span>) {
              node.args.shift();
            }
            node[<span class="hljs-string">'new'</span>] = <span class="hljs-string">'new'</span>;
            node.method = <span class="hljs-string">''</span>;
            <span class="hljs-keyword">return</span> it;
          }
        }
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">'~'</span>:
        <span class="hljs-keyword">if</span> (it <span class="hljs-keyword">instanceof</span> Fun &amp;&amp; it.statement &amp;&amp; !it.bound) {
          <span class="hljs-keyword">return</span> it.bound = <span class="hljs-string">'this$'</span>, it;
        }
      }
    }
    <span class="hljs-keyword">this</span>$.op = op;
    <span class="hljs-keyword">this</span>$.it = it;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.children = [<span class="hljs-string">'it'</span>];
  prototype.show = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">this</span>.post ? <span class="hljs-string">'@'</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>] + <span class="hljs-keyword">this</span>.op;
  };
  prototype.isCallable = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> ref$;
    <span class="hljs-keyword">return</span> ((ref$ = <span class="hljs-keyword">this</span>.op) === <span class="hljs-string">'do'</span> || ref$ === <span class="hljs-string">'new'</span> || ref$ === <span class="hljs-string">'delete'</span>) || <span class="hljs-keyword">this</span>.it == <span class="hljs-literal">null</span>;
  };
  prototype.isArray = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.it <span class="hljs-keyword">instanceof</span> Arr &amp;&amp; <span class="hljs-keyword">this</span>.it.items.length || <span class="hljs-keyword">this</span>.it <span class="hljs-keyword">instanceof</span> Chain &amp;&amp; <span class="hljs-keyword">this</span>.it.isArray();
  };
  prototype.isString = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> ref$;
    <span class="hljs-keyword">return</span> (ref$ = <span class="hljs-keyword">this</span>.op) === <span class="hljs-string">'typeof'</span> || ref$ === <span class="hljs-string">'classof'</span>;
  };
  prototype.invert = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> ref$;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.op === <span class="hljs-string">'!'</span> &amp;&amp; ((ref$ = <span class="hljs-keyword">this</span>.it.op) === <span class="hljs-string">'!'</span> || ref$ === <span class="hljs-string">'&lt;'</span> || ref$ === <span class="hljs-string">'&gt;'</span> || ref$ === <span class="hljs-string">'&lt;='</span> || ref$ === <span class="hljs-string">'&gt;='</span> || ref$ === <span class="hljs-string">'of'</span> || ref$ === <span class="hljs-string">'instanceof'</span>)) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.it;
    }
    <span class="hljs-keyword">return</span> constructor(<span class="hljs-string">'!'</span>, <span class="hljs-keyword">this</span>, <span class="hljs-literal">true</span>);
  };
  prototype.unfoldSoak = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> ref$;
    <span class="hljs-keyword">return</span> ((ref$ = <span class="hljs-keyword">this</span>.op) === <span class="hljs-string">'++'</span> || ref$ === <span class="hljs-string">'--'</span> || ref$ === <span class="hljs-string">'delete'</span>) &amp;&amp; <span class="hljs-keyword">this</span>.it != <span class="hljs-literal">null</span> &amp;&amp; If.unfoldSoak(o, <span class="hljs-keyword">this</span>, <span class="hljs-string">'it'</span>);
  };
  prototype.getAccessors = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> items;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.op !== <span class="hljs-string">'~'</span>) {
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.it <span class="hljs-keyword">instanceof</span> Fun) {
      <span class="hljs-keyword">return</span> [<span class="hljs-keyword">this</span>.it];
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.it <span class="hljs-keyword">instanceof</span> Arr) {
      items = <span class="hljs-keyword">this</span>.it.items;
      <span class="hljs-keyword">if</span> (!items[<span class="hljs-number">2</span>] &amp;&amp; items[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> Fun &amp;&amp; items[<span class="hljs-number">1</span>] <span class="hljs-keyword">instanceof</span> Fun) {
        <span class="hljs-keyword">return</span> items;
      }
    }
  };
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">crement</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">return</span> {
      <span class="hljs-string">'++'</span>: <span class="hljs-string">'in'</span>,
      <span class="hljs-string">'--'</span>: <span class="hljs-string">'de'</span>
    }[it] + <span class="hljs-string">'crement'</span>;
  }
  prototype.compileNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> that, op, it, x, code;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.it == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileAsFunc(o);
    }
    <span class="hljs-keyword">if</span> (that = <span class="hljs-keyword">this</span>.compileSpread(o)) {
      <span class="hljs-keyword">return</span> that;
    }
    op = <span class="hljs-keyword">this</span>.op, it = <span class="hljs-keyword">this</span>.it;
    <span class="hljs-keyword">switch</span> (op) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'!'</span>:
      it.cond = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'new'</span>:
      it.isCallable() || it.carp(<span class="hljs-string">'invalid constructor'</span>);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'do'</span>:
      <span class="hljs-keyword">if</span> (o.level === LEVEL_TOP &amp;&amp; it <span class="hljs-keyword">instanceof</span> Fun &amp;&amp; it.isStatement()) {
        <span class="hljs-keyword">return</span> it.compile(o) + <span class="hljs-string">" "</span> + Unary(<span class="hljs-string">'do'</span>, Var(it.name)).compile(o);
      }
      x = Parens(it <span class="hljs-keyword">instanceof</span> Existence &amp;&amp; !it.negated
        ? Chain(it).add(Call())
        : Call.make(it));
      <span class="hljs-keyword">return</span> (x.front = <span class="hljs-keyword">this</span>.front, x.newed = <span class="hljs-keyword">this</span>.newed, x).compile(o);
    <span class="hljs-keyword">case</span> <span class="hljs-string">'delete'</span>:
      <span class="hljs-keyword">if</span> (it <span class="hljs-keyword">instanceof</span> Var || !it.isAssignable()) {
        <span class="hljs-keyword">this</span>.carp(<span class="hljs-string">'invalid delete'</span>);
      }
      <span class="hljs-keyword">if</span> (o.level &amp;&amp; !<span class="hljs-keyword">this</span>[<span class="hljs-string">'void'</span>]) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compilePluck(o);
      }
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'++'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'--'</span>:
      it.isAssignable() || <span class="hljs-keyword">this</span>.carp(<span class="hljs-string">'invalid '</span> + crement(op));
      <span class="hljs-keyword">if</span> (that = it <span class="hljs-keyword">instanceof</span> Var &amp;&amp; o.scope.checkReadOnly(it.value)) {
        <span class="hljs-keyword">this</span>.carp(crement(op) + <span class="hljs-string">" of "</span> + that + <span class="hljs-string">" \""</span> + it.value + <span class="hljs-string">"\""</span>, <span class="hljs-built_in">ReferenceError</span>);
      }
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.post) {
        it.front = <span class="hljs-keyword">this</span>.front;
      }
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'^^'</span>:
      <span class="hljs-keyword">return</span> util(<span class="hljs-string">'clone'</span>) + <span class="hljs-string">"("</span> + it.compile(o, LEVEL_LIST) + <span class="hljs-string">")"</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'jsdelete'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">"delete "</span> + it.compile(o, LEVEL_LIST);
    <span class="hljs-keyword">case</span> <span class="hljs-string">'classof'</span>:
      <span class="hljs-keyword">return</span> util(<span class="hljs-string">'toString'</span>) + <span class="hljs-string">".call("</span> + it.compile(o, LEVEL_LIST) + <span class="hljs-string">").slice(8, -1)"</span>;
    }
    code = it.compile(o, LEVEL_OP + PREC.unary);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.post) {
      code += op;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (op === <span class="hljs-string">'yieldfrom'</span>) {
        op = <span class="hljs-string">'yield* '</span>;
      }
      <span class="hljs-keyword">if</span> ((op === <span class="hljs-string">'new'</span> || op === <span class="hljs-string">'typeof'</span> || op === <span class="hljs-string">'delete'</span> || op === <span class="hljs-string">'yield'</span>) || (op === <span class="hljs-string">'+'</span> || op === <span class="hljs-string">'-'</span>) &amp;&amp; op === code.charAt()) {
        op += <span class="hljs-string">' '</span>;
      }
      code = op + code;
    }
    <span class="hljs-keyword">if</span> (o.level &lt; LEVEL_CALL) {
      <span class="hljs-keyword">return</span> code;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"("</span> + code + <span class="hljs-string">")"</span>;
    }
  };
  prototype.compileSpread = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> it, ops, them, i$, len$, i, node, sp, j$, op, lat, ref$;
    it = <span class="hljs-keyword">this</span>.it;
    ops = [<span class="hljs-keyword">this</span>];
    <span class="hljs-keyword">for</span> (; it <span class="hljs-keyword">instanceof</span> constructor; it = it.it) {
      ops.push(it);
    }
    <span class="hljs-keyword">if</span> (!((it = it.expandSlice(o).unwrap()) <span class="hljs-keyword">instanceof</span> Arr &amp;&amp; (them = it.items).length)) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
    }
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = them.length; i$ &lt; len$; ++i$) {
      i = i$;
      node = them[i$];
      <span class="hljs-keyword">if</span> (sp = node <span class="hljs-keyword">instanceof</span> Splat) {
        node = node.it;
      }
      <span class="hljs-keyword">for</span> (j$ = ops.length - <span class="hljs-number">1</span>; j$ &gt;= <span class="hljs-number">0</span>; --j$) {
        op = ops[j$];
        node = constructor(op.op, node, op.post);
      }
      them[i] = sp ? lat = Splat(node) : node;
    }
    <span class="hljs-keyword">if</span> (!lat &amp;&amp; (<span class="hljs-keyword">this</span>[<span class="hljs-string">'void'</span>] || !o.level)) {
      it = (ref$ = Block(them), ref$.front = <span class="hljs-keyword">this</span>.front, ref$[<span class="hljs-string">'void'</span>] = <span class="hljs-literal">true</span>, ref$);
    }
    <span class="hljs-keyword">return</span> it.compile(o, LEVEL_PAREN);
  };
  prototype.compilePluck = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> ref$, get, del, code, ref;
    ref$ = Chain(<span class="hljs-keyword">this</span>.it).cacheReference(o), get = ref$[<span class="hljs-number">0</span>], del = ref$[<span class="hljs-number">1</span>];
    code = (ref = o.scope.temporary()) + <span class="hljs-string">" = "</span> + get.compile(o, LEVEL_LIST) + <span class="hljs-string">", delete "</span> + del.compile(o, LEVEL_LIST) + <span class="hljs-string">", "</span> + o.scope.free(ref);
    <span class="hljs-keyword">if</span> (o.level &lt; LEVEL_LIST) {
      <span class="hljs-keyword">return</span> code;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"("</span> + code + <span class="hljs-string">")"</span>;
    }
  };
  prototype.compileAsFunc = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.op === <span class="hljs-string">'!'</span>) {
      <span class="hljs-keyword">return</span> util(<span class="hljs-string">'not'</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"("</span> + Fun([], Block(Unary(<span class="hljs-keyword">this</span>.op, Chain(Var(<span class="hljs-string">'it'</span>))))).compile(o) + <span class="hljs-string">")"</span>;
    }
  };
  <span class="hljs-keyword">return</span> Unary;
}(Node));
exports.Binary = Binary = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> COMPARER, INVERSIONS, prototype = extend$((import$(Binary, superclass).displayName = <span class="hljs-string">'Binary'</span>, Binary), superclass).prototype, constructor = Binary;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Binary</span><span class="hljs-params">(op, first, second, destructuring)</span>{</span>
    <span class="hljs-keyword">var</span> logic, that, ref$, <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">if</span> (destructuring) {
      logic = op.logic;
      <span class="hljs-keyword">if</span> (toString$.call(destructuring).slice(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>) === <span class="hljs-string">'String'</span>) {
        logic = destructuring;
      }
      op = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
        <span class="hljs-keyword">switch</span> (<span class="hljs-literal">false</span>) {
        <span class="hljs-keyword">case</span> !(that = logic):
          <span class="hljs-keyword">return</span> that;
        <span class="hljs-keyword">case</span> op !== <span class="hljs-string">'='</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-string">'?'</span>;
        <span class="hljs-keyword">default</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-string">'='</span>;
        }
      }());
    }
    <span class="hljs-keyword">this</span>$.partial = first == <span class="hljs-literal">null</span> || second == <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>$.partial) {
      <span class="hljs-keyword">if</span> (<span class="hljs-string">'='</span> === op.charAt(op.length - <span class="hljs-number">1</span>) &amp;&amp; ((ref$ = op.charAt(op.length - <span class="hljs-number">2</span>)) !== <span class="hljs-string">'='</span> &amp;&amp; ref$ !== <span class="hljs-string">'&lt;'</span> &amp;&amp; ref$ !== <span class="hljs-string">'&gt;'</span> &amp;&amp; ref$ !== <span class="hljs-string">'!'</span>)) {
        <span class="hljs-keyword">return</span> Assign(first.unwrap(), second, op);
      }
      <span class="hljs-keyword">switch</span> (op) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'in'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> In(first, second);
      <span class="hljs-keyword">case</span> <span class="hljs-string">'with'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Import(Unary(<span class="hljs-string">'^^'</span>, first), second, <span class="hljs-literal">false</span>);
      <span class="hljs-keyword">case</span> <span class="hljs-string">'&lt;&lt;&lt;'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'&lt;&lt;&lt;&lt;'</span>:
        <span class="hljs-keyword">return</span> Import(first, second, op === <span class="hljs-string">'&lt;&lt;&lt;&lt;'</span>);
      <span class="hljs-keyword">case</span> <span class="hljs-string">'&lt;|'</span>:
        <span class="hljs-keyword">return</span> Block(first).pipe(second, op);
      <span class="hljs-keyword">case</span> <span class="hljs-string">'|&gt;'</span>:
        <span class="hljs-keyword">return</span> Block(second).pipe(first, <span class="hljs-string">'&lt;|'</span>);
      <span class="hljs-keyword">case</span> <span class="hljs-string">'.'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'.~'</span>:
        <span class="hljs-keyword">return</span> Chain(first).add(Index(second, op));
      }
    }
    <span class="hljs-keyword">this</span>$.op = op;
    <span class="hljs-keyword">this</span>$.first = first;
    <span class="hljs-keyword">this</span>$.second = second;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.children = [<span class="hljs-string">'first'</span>, <span class="hljs-string">'second'</span>];
  prototype.show = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.op;
  };
  prototype.isCallable = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> ref$;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.partial || ((ref$ = <span class="hljs-keyword">this</span>.op) === <span class="hljs-string">'&amp;&amp;'</span> || ref$ === <span class="hljs-string">'||'</span> || ref$ === <span class="hljs-string">'?'</span> || ref$ === <span class="hljs-string">'&lt;&lt;'</span> || ref$ === <span class="hljs-string">'&gt;&gt;'</span>) &amp;&amp; <span class="hljs-keyword">this</span>.first.isCallable() &amp;&amp; <span class="hljs-keyword">this</span>.second.isCallable();
  };
  prototype.isArray = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.op) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.first.isArray();
    <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.second.isMatcher();
    }
  };
  prototype.isString = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.op) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.first.isString() || <span class="hljs-keyword">this</span>.second.isString();
    <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.second.isMatcher();
    }
  };
  COMPARER = <span class="hljs-regexp">/^(?:[!=]=|[&lt;&gt;])=?$/</span>;
  INVERSIONS = {
    <span class="hljs-string">'==='</span>: <span class="hljs-string">'!=='</span>,
    <span class="hljs-string">'!=='</span>: <span class="hljs-string">'==='</span>,
    <span class="hljs-string">'=='</span>: <span class="hljs-string">'!='</span>,
    <span class="hljs-string">'!='</span>: <span class="hljs-string">'=='</span>
  };
  prototype.invert = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> that;
    <span class="hljs-keyword">if</span> (that = !COMPARER.test(<span class="hljs-keyword">this</span>.second.op) &amp;&amp; INVERSIONS[<span class="hljs-keyword">this</span>.op]) {
      <span class="hljs-keyword">this</span>.op = that;
      <span class="hljs-keyword">this</span>.wasInverted = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
    <span class="hljs-keyword">return</span> Unary(<span class="hljs-string">'!'</span>, Parens(<span class="hljs-keyword">this</span>), <span class="hljs-literal">true</span>);
  };
  prototype.invertIt = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">this</span>.inverted = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  prototype.getDefault = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.op) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'?'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'||'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'&amp;&amp;'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
  };
  prototype.xorChildren = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(test)</span>{</span>
    <span class="hljs-keyword">var</span> ref$, ref1$, first;
    <span class="hljs-keyword">if</span> (!(!(ref$ = first = test(<span class="hljs-keyword">this</span>.first)) !== !(ref1$ = test(<span class="hljs-keyword">this</span>.second)) &amp;&amp; (ref$ || ref1$))) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">return</span> first
      ? [<span class="hljs-keyword">this</span>.first, <span class="hljs-keyword">this</span>.second]
      : [<span class="hljs-keyword">this</span>.second, <span class="hljs-keyword">this</span>.first];
  };
  prototype.compileNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> top, rite, items, that, ref$, code, level;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.partial) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compilePartial(o);
    }
    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.op) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'?'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileExistence(o);
    <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.second.isString()) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileJoin(o);
      }
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.first.isString() || <span class="hljs-keyword">this</span>.first.isArray()) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileRepeat(o);
      }
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.second.isMatcher()) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileRemove(o);
      }
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.second.isMatcher()) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileSplit(o);
      }
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'**'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'^'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compilePow(o);
    <span class="hljs-keyword">case</span> <span class="hljs-string">'&lt;?'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'&gt;?'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileMinMax(o);
    <span class="hljs-keyword">case</span> <span class="hljs-string">'&lt;&lt;'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'&gt;&gt;'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileCompose(o);
    <span class="hljs-keyword">case</span> <span class="hljs-string">'++'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileConcat(o);
    <span class="hljs-keyword">case</span> <span class="hljs-string">'%%'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileMod(o);
    <span class="hljs-keyword">case</span> <span class="hljs-string">'xor'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileXor(o);
    <span class="hljs-keyword">case</span> <span class="hljs-string">'&amp;&amp;'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'||'</span>:
      <span class="hljs-keyword">if</span> (top = <span class="hljs-keyword">this</span>[<span class="hljs-string">'void'</span>] || !o.level) {
        <span class="hljs-keyword">this</span>.second[<span class="hljs-string">'void'</span>] = <span class="hljs-literal">true</span>;
      }
      <span class="hljs-keyword">if</span> (top || <span class="hljs-keyword">this</span>.cond) {
        <span class="hljs-keyword">this</span>.first.cond = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">this</span>.second.cond = <span class="hljs-literal">true</span>;
      }
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'instanceof'</span>:
      rite = <span class="hljs-keyword">this</span>.second.expandSlice(o).unwrap(), items = rite.items;
      <span class="hljs-keyword">if</span> (rite <span class="hljs-keyword">instanceof</span> Arr) {
        <span class="hljs-keyword">if</span> (items[<span class="hljs-number">1</span>]) {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileAnyInstanceOf(o, items);
        }
        <span class="hljs-keyword">this</span>.second = items[<span class="hljs-number">0</span>] || rite;
      }
      <span class="hljs-keyword">this</span>.second.isCallable() || <span class="hljs-keyword">this</span>.second.carp(<span class="hljs-string">'invalid instanceof operand'</span>);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'===='</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'!==='</span>:
      <span class="hljs-keyword">this</span>.op = <span class="hljs-keyword">this</span>.op.slice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>fallthrough</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">case</span> <span class="hljs-string">'&lt;=='</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'&gt;=='</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'&lt;&lt;='</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'&gt;&gt;='</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileDeepEq(o);
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">if</span> (COMPARER.test(<span class="hljs-keyword">this</span>.op)) {
        <span class="hljs-keyword">if</span> (that = ((ref$ = <span class="hljs-keyword">this</span>.op) === <span class="hljs-string">'==='</span> || ref$ === <span class="hljs-string">'!=='</span>) &amp;&amp; <span class="hljs-keyword">this</span>.xorChildren(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
          <span class="hljs-keyword">return</span> it.isRegex();
        })) {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileRegexEquals(o, that);
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.op === <span class="hljs-string">'==='</span> &amp;&amp; (<span class="hljs-keyword">this</span>.first <span class="hljs-keyword">instanceof</span> Literal &amp;&amp; <span class="hljs-keyword">this</span>.second <span class="hljs-keyword">instanceof</span> Literal) &amp;&amp; <span class="hljs-keyword">this</span>.first.isWhat() !== <span class="hljs-keyword">this</span>.second.isWhat()) {
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> console != <span class="hljs-string">'undefined'</span> &amp;&amp; console !== <span class="hljs-literal">null</span>) {
            console.warn(<span class="hljs-string">"WARNING: strict comparison of two different types will always be false: "</span> + <span class="hljs-keyword">this</span>.first.value + <span class="hljs-string">" == "</span> + <span class="hljs-keyword">this</span>.second.value);
          }
        }
      }
      <span class="hljs-keyword">if</span> (COMPARER.test(<span class="hljs-keyword">this</span>.op) &amp;&amp; COMPARER.test(<span class="hljs-keyword">this</span>.second.op)) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileChain(o);
      }
    }
    <span class="hljs-keyword">this</span>.first.front = <span class="hljs-keyword">this</span>.front;
    code = <span class="hljs-keyword">this</span>.first.compile(o, level = LEVEL_OP + PREC[<span class="hljs-keyword">this</span>.op]) + <span class="hljs-string">" "</span> + <span class="hljs-keyword">this</span>.mapOp(<span class="hljs-keyword">this</span>.op) + <span class="hljs-string">" "</span> + <span class="hljs-keyword">this</span>.second.compile(o, level);
    <span class="hljs-keyword">if</span> (o.level &lt;= level) {
      <span class="hljs-keyword">return</span> code;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"("</span> + code + <span class="hljs-string">")"</span>;
    }
  };
  prototype.mapOp = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(op)</span>{</span>
    <span class="hljs-keyword">var</span> that;
    <span class="hljs-keyword">switch</span> (<span class="hljs-literal">false</span>) {
    <span class="hljs-keyword">case</span> !(that = op.match(<span class="hljs-regexp">/\.([&amp;\|\^]|&lt;&lt;|&gt;&gt;&gt;?)\./</span>)):
      <span class="hljs-keyword">return</span> that[<span class="hljs-number">1</span>];
    <span class="hljs-keyword">case</span> op !== <span class="hljs-string">'of'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">'in'</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> op;
    }
  };
  prototype.compileChain = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> code, level, ref$, sub;
    code = <span class="hljs-keyword">this</span>.first.compile(o, level = LEVEL_OP + PREC[<span class="hljs-keyword">this</span>.op]);
    ref$ = <span class="hljs-keyword">this</span>.second.first.cache(o, <span class="hljs-literal">true</span>), sub = ref$[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>.second.first = ref$[<span class="hljs-number">1</span>];
    code += <span class="hljs-string">" "</span> + <span class="hljs-keyword">this</span>.op + <span class="hljs-string">" "</span> + sub.compile(o, level) + <span class="hljs-string">" &amp;&amp; "</span> + <span class="hljs-keyword">this</span>.second.compile(o, LEVEL_OP);
    <span class="hljs-keyword">if</span> (o.level &lt;= LEVEL_OP) {
      <span class="hljs-keyword">return</span> code;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"("</span> + code + <span class="hljs-string">")"</span>;
    }
  };
  prototype.compileExistence = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> x;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[<span class="hljs-string">'void'</span>] || !o.level) {
      x = Binary(<span class="hljs-string">'&amp;&amp;'</span>, Existence(<span class="hljs-keyword">this</span>.first, <span class="hljs-literal">true</span>), <span class="hljs-keyword">this</span>.second);
      <span class="hljs-keyword">return</span> (x[<span class="hljs-string">'void'</span>] = <span class="hljs-literal">true</span>, x).compileNode(o);
    }
    x = <span class="hljs-keyword">this</span>.first.cache(o, <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">return</span> If(Existence(x[<span class="hljs-number">0</span>]), x[<span class="hljs-number">1</span>]).addElse(<span class="hljs-keyword">this</span>.second).compileExpression(o);
  };
  prototype.compileAnyInstanceOf = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, items)</span>{</span>
    <span class="hljs-keyword">var</span> ref$, sub, ref, test, i$, len$, item;
    ref$ = <span class="hljs-keyword">this</span>.first.cache(o), sub = ref$[<span class="hljs-number">0</span>], ref = ref$[<span class="hljs-number">1</span>], <span class="hljs-keyword">this</span>.temps = ref$[<span class="hljs-number">2</span>];
    test = Binary(<span class="hljs-string">'instanceof'</span>, sub, items.shift());
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = items.length; i$ &lt; len$; ++i$) {
      item = items[i$];
      test = Binary(<span class="hljs-string">'||'</span>, test, Binary(<span class="hljs-string">'instanceof'</span>, ref, item));
    }
    <span class="hljs-keyword">return</span> Parens(test).compile(o);
  };
  prototype.compileMinMax = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> lefts, rites, x;
    lefts = <span class="hljs-keyword">this</span>.first.cache(o, <span class="hljs-literal">true</span>);
    rites = <span class="hljs-keyword">this</span>.second.cache(o, <span class="hljs-literal">true</span>);
    x = Binary(<span class="hljs-keyword">this</span>.op.charAt(), lefts[<span class="hljs-number">0</span>], rites[<span class="hljs-number">0</span>]);
    <span class="hljs-keyword">return</span> If(x, lefts[<span class="hljs-number">1</span>]).addElse(rites[<span class="hljs-number">1</span>]).compileExpression(o);
  };
  prototype.compileMethod = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, klass, method, arg)</span>{</span>
    <span class="hljs-keyword">var</span> args;
    args = [<span class="hljs-keyword">this</span>.second].concat(arg || []);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.first[<span class="hljs-string">"is"</span> + klass]()) {
      <span class="hljs-keyword">return</span> Chain(<span class="hljs-keyword">this</span>.first, [Index(Key(method)), Call(args)]).compile(o);
    } <span class="hljs-keyword">else</span> {
      args.unshift(<span class="hljs-keyword">this</span>.first);
      <span class="hljs-keyword">return</span> Call.make(JS(util(method) + <span class="hljs-string">'.call'</span>), args).compile(o);
    }
  };
  prototype.compileJoin = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileMethod(it, <span class="hljs-string">'Array'</span>, <span class="hljs-string">'join'</span>);
  };
  prototype.compileRemove = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileMethod(it, <span class="hljs-string">'String'</span>, <span class="hljs-string">'replace'</span>, JS(<span class="hljs-string">"''"</span>));
  };
  prototype.compileSplit = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileMethod(it, <span class="hljs-string">'String'</span>, <span class="hljs-string">'split'</span>);
  };
  prototype.compileRepeat = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> x, n, items, arr, that, refs, i$, len$, i, item, ref$, q;
    x = <span class="hljs-keyword">this</span>.first, n = <span class="hljs-keyword">this</span>.second;
    items = (x = x.expandSlice(o).unwrap()).items;
    arr = x.isArray() &amp;&amp; <span class="hljs-string">'Array'</span>;
    <span class="hljs-keyword">if</span> (that = items &amp;&amp; Splat.compileArray(o, items)) {
      x = JS(that);
      items = <span class="hljs-literal">null</span>;
    }
    <span class="hljs-keyword">if</span> (arr &amp;&amp; !items || !(n <span class="hljs-keyword">instanceof</span> Literal &amp;&amp; n.value &lt; <span class="hljs-number">0x20</span>)) {
      <span class="hljs-keyword">return</span> Call.make(Util(<span class="hljs-string">'repeat'</span> + (arr || <span class="hljs-string">'String'</span>)), [x, n]).compile(o);
    }
    n = +n.value;
    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &lt;= n &amp;&amp; n &lt; <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">return</span> x.compile(o);
    }
    <span class="hljs-keyword">if</span> (items) {
      <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> Block(items).add(JS(<span class="hljs-string">'[]'</span>)).compile(o);
      }
      refs = [];
      <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = items.length; i$ &lt; len$; ++i$) {
        i = i$;
        item = items[i$];
        ref$ = item.cache(o, <span class="hljs-number">1</span>), items[i] = ref$[<span class="hljs-number">0</span>], refs[refs.length] = ref$[<span class="hljs-number">1</span>];
      }
      items.push((ref$ = JS(), ref$.compile = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
        <span class="hljs-keyword">return</span> (repeatString$(<span class="hljs-string">", "</span> + List.compile(o, refs), n - <span class="hljs-number">1</span>)).slice(<span class="hljs-number">2</span>);
      }, ref$));
      <span class="hljs-keyword">return</span> x.compile(o);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> Literal) {
      <span class="hljs-keyword">return</span> (q = (x = x.compile(o)).charAt()) + repeatString$(x.slice(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>) + <span class="hljs-string">""</span>, n) + q;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> Block(x.it).add(JS(<span class="hljs-string">"''"</span>)).compile(o);
      }
      x = (refs = x.cache(o, <span class="hljs-number">1</span>, LEVEL_OP))[<span class="hljs-number">0</span>] + repeatString$(<span class="hljs-string">" + "</span> + refs[<span class="hljs-number">1</span>], n - <span class="hljs-number">1</span>);
      <span class="hljs-keyword">if</span> (o.level &lt; LEVEL_OP + PREC[<span class="hljs-string">'+'</span>]) {
        <span class="hljs-keyword">return</span> x;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"("</span> + x + <span class="hljs-string">")"</span>;
      }
    }
  };
  prototype.compilePow = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">return</span> Call.make(JS(<span class="hljs-string">'Math.pow'</span>), [<span class="hljs-keyword">this</span>.first, <span class="hljs-keyword">this</span>.second]).compile(o);
  };
  prototype.compileConcat = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> f;
    f = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span>{</span>
      <span class="hljs-keyword">switch</span> (<span class="hljs-literal">false</span>) {
      <span class="hljs-keyword">case</span> !(x <span class="hljs-keyword">instanceof</span> Binary &amp;&amp; x.op === <span class="hljs-string">'++'</span>):
        <span class="hljs-keyword">return</span> f(x.first).concat(f(x.second));
      <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">return</span> [x];
      }
    };
    <span class="hljs-keyword">return</span> Chain(<span class="hljs-keyword">this</span>.first).add(Index(Key(<span class="hljs-string">'concat'</span>), <span class="hljs-string">'.'</span>, <span class="hljs-literal">true</span>)).add(Call(f(<span class="hljs-keyword">this</span>.second))).compile(o);
  };
  prototype.compileCompose = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> op, functions, x;
    op = <span class="hljs-keyword">this</span>.op;
    functions = [<span class="hljs-keyword">this</span>.first];
    x = <span class="hljs-keyword">this</span>.second;
    <span class="hljs-keyword">while</span> (x <span class="hljs-keyword">instanceof</span> Binary &amp;&amp; x.op === op) {
      functions.push(x.first);
      x = x.second;
    }
    functions.push(x);
    <span class="hljs-keyword">if</span> (op === <span class="hljs-string">'&lt;&lt;'</span>) {
      functions.reverse();
    }
    <span class="hljs-keyword">return</span> Chain(Var(util(<span class="hljs-string">'compose'</span>))).add(Call(functions)).compile(o);
  };
  prototype.compileMod = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> ref, code;
    ref = o.scope.temporary();
    code = <span class="hljs-string">"((("</span> + <span class="hljs-keyword">this</span>.first.compile(o) + <span class="hljs-string">") % ("</span> + ref + <span class="hljs-string">" = "</span> + <span class="hljs-keyword">this</span>.second.compile(o) + <span class="hljs-string">") + "</span> + ref + <span class="hljs-string">") % "</span> + ref + <span class="hljs-string">")"</span>;
    o.scope.free(ref);
    <span class="hljs-keyword">return</span> code;
  };
  prototype.compilePartial = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> vit, x, y;
    vit = Var(<span class="hljs-string">'it'</span>);
    <span class="hljs-keyword">switch</span> (<span class="hljs-literal">false</span>) {
    <span class="hljs-keyword">case</span> !(<span class="hljs-keyword">this</span>.first == <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.second == <span class="hljs-literal">null</span>):
      x = Var(<span class="hljs-string">'x$'</span>);
      y = Var(<span class="hljs-string">'y$'</span>);
      <span class="hljs-keyword">return</span> Fun([x, y], Block(Binary(<span class="hljs-keyword">this</span>.op, x, y).invertCheck(<span class="hljs-keyword">this</span>)), <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>).compile(o);
    <span class="hljs-keyword">case</span> <span class="hljs-keyword">this</span>.first == <span class="hljs-literal">null</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">"("</span> + Fun([vit], Block(Binary(<span class="hljs-keyword">this</span>.op, <span class="hljs-keyword">this</span>.first, vit).invertCheck(<span class="hljs-keyword">this</span>))).compile(o) + <span class="hljs-string">")"</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">"("</span> + Fun([vit], Block(Binary(<span class="hljs-keyword">this</span>.op, vit, <span class="hljs-keyword">this</span>.second).invertCheck(<span class="hljs-keyword">this</span>))).compile(o) + <span class="hljs-string">")"</span>;
    }
  };
  prototype.compileRegexEquals = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, arg$)</span>{</span>
    <span class="hljs-keyword">var</span> regex, target, method;
    regex = arg$[<span class="hljs-number">0</span>], target = arg$[<span class="hljs-number">1</span>];
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.op === <span class="hljs-string">'==='</span>) {
      method = <span class="hljs-keyword">this</span>.wasInverted ? <span class="hljs-string">'test'</span> : <span class="hljs-string">'exec'</span>;
      <span class="hljs-keyword">return</span> Chain(regex).add(Index(Key(method))).add(Call([target])).compile(o);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> Unary(<span class="hljs-string">'!'</span>, Chain(regex).add(Index(Key(<span class="hljs-string">'test'</span>))).add(Call([target]))).compile(o);
    }
  };
  prototype.compileDeepEq = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> ref$, negate, i$, len$, x, r;
    <span class="hljs-keyword">if</span> ((ref$ = <span class="hljs-keyword">this</span>.op) === <span class="hljs-string">'&gt;=='</span> || ref$ === <span class="hljs-string">'&gt;&gt;='</span>) {
      ref$ = [<span class="hljs-keyword">this</span>.second, <span class="hljs-keyword">this</span>.first], <span class="hljs-keyword">this</span>.first = ref$[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>.second = ref$[<span class="hljs-number">1</span>];
      <span class="hljs-keyword">this</span>.op = <span class="hljs-keyword">this</span>.op === <span class="hljs-string">'&gt;=='</span> ? <span class="hljs-string">'&lt;=='</span> : <span class="hljs-string">'&lt;&lt;='</span>;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.op === <span class="hljs-string">'!=='</span>) {
      <span class="hljs-keyword">this</span>.op = <span class="hljs-string">'==='</span>;
      negate = <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = [<span class="hljs-keyword">this</span>.first, <span class="hljs-keyword">this</span>.second]).length; i$ &lt; len$; ++i$) {
      x = ref$[i$];
      <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> Obj || x <span class="hljs-keyword">instanceof</span> Arr) {
        x.deepEq = <span class="hljs-literal">true</span>;
      }
    }
    r = Chain(Var(util(<span class="hljs-string">'deepEq'</span>))).add(Call([<span class="hljs-keyword">this</span>.first, <span class="hljs-keyword">this</span>.second, Literal(<span class="hljs-string">"'"</span> + <span class="hljs-keyword">this</span>.op + <span class="hljs-string">"'"</span>)]));
    <span class="hljs-keyword">return</span> (negate ? Unary(<span class="hljs-string">'!'</span>, r) : r).compile(o);
  };
  prototype.compileXor = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> left, right;
    left = Chain(<span class="hljs-keyword">this</span>.first).cacheReference(o);
    right = Chain(<span class="hljs-keyword">this</span>.second).cacheReference(o);
    <span class="hljs-keyword">return</span> Binary(<span class="hljs-string">'&amp;&amp;'</span>, Binary(<span class="hljs-string">'!=='</span>, Unary(<span class="hljs-string">'!'</span>, left[<span class="hljs-number">0</span>]), Unary(<span class="hljs-string">'!'</span>, right[<span class="hljs-number">0</span>])), Parens(Binary(<span class="hljs-string">'||'</span>, left[<span class="hljs-number">1</span>], right[<span class="hljs-number">1</span>]))).compile(o);
  };
  <span class="hljs-keyword">return</span> Binary;
}(Node));
exports.Assign = Assign = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Assign, superclass).displayName = <span class="hljs-string">'Assign'</span>, Assign), superclass).prototype, constructor = Assign;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Assign</span><span class="hljs-params">(left, rite, op, logic, defParam)</span>{</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">this</span>$.left = left;
    <span class="hljs-keyword">this</span>$.op = op || <span class="hljs-string">'='</span>;
    <span class="hljs-keyword">this</span>$.logic = logic || <span class="hljs-keyword">this</span>$.op.logic;
    <span class="hljs-keyword">this</span>$.defParam = defParam;
    <span class="hljs-keyword">this</span>$.op += <span class="hljs-string">''</span>;
    <span class="hljs-keyword">this</span>$[rite <span class="hljs-keyword">instanceof</span> Node ? <span class="hljs-string">'right'</span> : <span class="hljs-string">'unaries'</span>] = rite;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.children = [<span class="hljs-string">'left'</span>, <span class="hljs-string">'right'</span>];
  prototype.show = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">void</span> <span class="hljs-number">8</span>].concat(<span class="hljs-keyword">this</span>.unaries).reverse().join(<span class="hljs-string">' '</span>) + [<span class="hljs-keyword">this</span>.logic] + <span class="hljs-keyword">this</span>.op;
  };
  prototype.assigns = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.left.assigns(it);
  };
  prototype.delegate([<span class="hljs-string">'isCallable'</span>, <span class="hljs-string">'isRegex'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">var</span> ref$;
    <span class="hljs-keyword">return</span> ((ref$ = <span class="hljs-keyword">this</span>.op) === <span class="hljs-string">'='</span> || ref$ === <span class="hljs-string">':='</span>) &amp;&amp; <span class="hljs-keyword">this</span>.right[it]();
  });
  prototype.isArray = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.op) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'='</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">':='</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.right.isArray();
    <span class="hljs-keyword">case</span> <span class="hljs-string">'/='</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.right.isMatcher();
    }
  };
  prototype.isString = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.op) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'='</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">':='</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'+='</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'*='</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.right.isString();
    <span class="hljs-keyword">case</span> <span class="hljs-string">'-='</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.right.isMatcher();
    }
  };
  prototype.unfoldSoak = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> that, ref$, ref1$, rite, temps;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.left <span class="hljs-keyword">instanceof</span> Existence) {
      <span class="hljs-keyword">if</span> (that = (ref1$ = (ref$ = <span class="hljs-keyword">this</span>.left = <span class="hljs-keyword">this</span>.left.it).name, <span class="hljs-keyword">delete</span> ref$.name, ref1$)) {
        rite = <span class="hljs-keyword">this</span>.right;
        rite = Assign(<span class="hljs-keyword">this</span>.right = Var(that), rite);
      } <span class="hljs-keyword">else</span> {
        ref$ = <span class="hljs-keyword">this</span>.right.cache(o), rite = ref$[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>.right = ref$[<span class="hljs-number">1</span>], temps = ref$[<span class="hljs-number">2</span>];
      }
      <span class="hljs-keyword">return</span> ref$ = If(Existence(rite), <span class="hljs-keyword">this</span>), ref$.temps = temps, ref$.cond = <span class="hljs-keyword">this</span>.cond, ref$[<span class="hljs-string">'void'</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'void'</span>], ref$;
    }
    <span class="hljs-keyword">return</span> If.unfoldSoak(o, <span class="hljs-keyword">this</span>, <span class="hljs-string">'left'</span>);
  };
  prototype.unfoldAssign = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.access &amp;&amp; <span class="hljs-keyword">this</span>;
  };
  prototype.compileNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> left, ref$, i$, len$, op, right, reft, sign, name, lvar, that, protoSplit, dotSplit, code, empty, res;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.left <span class="hljs-keyword">instanceof</span> Slice &amp;&amp; <span class="hljs-keyword">this</span>.op === <span class="hljs-string">'='</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileSplice(o);
    }
    left = <span class="hljs-keyword">this</span>.left.expandSlice(o, <span class="hljs-literal">true</span>).unwrap();
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.right) {
      left.isAssignable() || left.carp(<span class="hljs-string">'invalid unary assign'</span>);
      ref$ = Chain(left).cacheReference(o), left = ref$[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>.right = ref$[<span class="hljs-number">1</span>];
      <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = <span class="hljs-keyword">this</span>.unaries).length; i$ &lt; len$; ++i$) {
        op = ref$[i$];
        <span class="hljs-keyword">this</span>.right = Unary(op, <span class="hljs-keyword">this</span>.right);
      }
    }
    <span class="hljs-keyword">if</span> (left.isEmpty()) {
      <span class="hljs-keyword">return</span> (ref$ = Parens(<span class="hljs-keyword">this</span>.right), ref$.front = <span class="hljs-keyword">this</span>.front, ref$.newed = <span class="hljs-keyword">this</span>.newed, ref$).compile(o);
    }
    <span class="hljs-keyword">if</span> (left.getDefault()) {
      <span class="hljs-keyword">this</span>.right = Binary(left.op, <span class="hljs-keyword">this</span>.right, left.second);
      left = left.first;
    }
    <span class="hljs-keyword">if</span> (left.items) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileDestructuring(o, left);
    }
    left.isAssignable() || left.carp(<span class="hljs-string">'invalid assign'</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logic) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileConditional(o, left);
    }
    op = <span class="hljs-keyword">this</span>.op, right = <span class="hljs-keyword">this</span>.right;
    <span class="hljs-keyword">if</span> (op === <span class="hljs-string">'&lt;?='</span> || op === <span class="hljs-string">'&gt;?='</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileMinMax(o, left, right);
    }
    <span class="hljs-keyword">if</span> ((op === <span class="hljs-string">'**='</span> || op === <span class="hljs-string">'^='</span> || op === <span class="hljs-string">'%%='</span> || op === <span class="hljs-string">'++='</span> || op === <span class="hljs-string">'|&gt;='</span>) || op === <span class="hljs-string">'*='</span> &amp;&amp; right.isString() || (op === <span class="hljs-string">'-='</span> || op === <span class="hljs-string">'/='</span>) &amp;&amp; right.isMatcher()) {
      ref$ = Chain(left).cacheReference(o), left = ref$[<span class="hljs-number">0</span>], reft = ref$[<span class="hljs-number">1</span>];
      right = Binary(op.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>), reft, right);
      op = <span class="hljs-string">':='</span>;
    }
    <span class="hljs-keyword">if</span> (op === <span class="hljs-string">'.&amp;.='</span> || op === <span class="hljs-string">'.|.='</span> || op === <span class="hljs-string">'.^.='</span> || op === <span class="hljs-string">'.&lt;&lt;.='</span> || op === <span class="hljs-string">'.&gt;&gt;.='</span> || op === <span class="hljs-string">'.&gt;&gt;&gt;.='</span>) {
      op = op.slice(<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>) + <span class="hljs-string">'='</span>;
    }
    (right = right.unparen()).ripName(left = left.unwrap());
    sign = op.replace(<span class="hljs-string">':'</span>, <span class="hljs-string">''</span>);
    name = (left.front = <span class="hljs-literal">true</span>, left).compile(o, LEVEL_LIST);
    <span class="hljs-keyword">if</span> (lvar = left <span class="hljs-keyword">instanceof</span> Var) {
      <span class="hljs-keyword">if</span> (op === <span class="hljs-string">'='</span>) {
        o.scope.declare(name, left, <span class="hljs-keyword">this</span>[<span class="hljs-string">'const'</span>] || !<span class="hljs-keyword">this</span>.defParam &amp;&amp; o[<span class="hljs-string">'const'</span>] &amp;&amp; <span class="hljs-string">'$'</span> !== name.slice(-<span class="hljs-number">1</span>));
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (that = o.scope.checkReadOnly(name)) {
        left.carp(<span class="hljs-string">"assignment to "</span> + that + <span class="hljs-string">" \""</span> + name + <span class="hljs-string">"\""</span>, <span class="hljs-built_in">ReferenceError</span>);
      }
    }
    <span class="hljs-keyword">if</span> (left <span class="hljs-keyword">instanceof</span> Chain &amp;&amp; right <span class="hljs-keyword">instanceof</span> Fun) {
      protoSplit = name.split(<span class="hljs-string">'.prototype.'</span>);
      dotSplit = name.split(<span class="hljs-string">'.'</span>);
      <span class="hljs-keyword">if</span> (protoSplit.length &gt; <span class="hljs-number">1</span>) {
        right.inClass = protoSplit[<span class="hljs-number">0</span>];
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dotSplit.length &gt; <span class="hljs-number">1</span>) {
        right.inClassStatic = slice$.call(dotSplit, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>).join(<span class="hljs-string">''</span>);
      }
    }
    code = !o.level &amp;&amp; right <span class="hljs-keyword">instanceof</span> While &amp;&amp; !right[<span class="hljs-string">'else'</span>] &amp;&amp; (lvar || left <span class="hljs-keyword">instanceof</span> Chain &amp;&amp; left.isSimpleAccess())
      ? (empty = right.objComp ? <span class="hljs-string">'{}'</span> : <span class="hljs-string">'[]'</span>, (res = o.scope.temporary(<span class="hljs-string">'res'</span>)) + <span class="hljs-string">" = "</span> + empty + <span class="hljs-string">";\n"</span> + <span class="hljs-keyword">this</span>.tab + right.makeReturn(res).compile(o) + <span class="hljs-string">"\n"</span> + <span class="hljs-keyword">this</span>.tab + name + <span class="hljs-string">" "</span> + sign + <span class="hljs-string">" "</span> + o.scope.free(res))
      : (name + <span class="hljs-string">" "</span> + sign + <span class="hljs-string">" "</span>) + right.compile(o, LEVEL_LIST);
    <span class="hljs-keyword">if</span> (o.level &gt; LEVEL_LIST) {
      code = <span class="hljs-string">"("</span> + code + <span class="hljs-string">")"</span>;
    }
    <span class="hljs-keyword">return</span> code;
  };
  prototype.compileConditional = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, left)</span>{</span>
    <span class="hljs-keyword">var</span> lefts, morph;
    <span class="hljs-keyword">if</span> (left <span class="hljs-keyword">instanceof</span> Var &amp;&amp; <span class="hljs-keyword">in</span>$(<span class="hljs-keyword">this</span>.logic, [<span class="hljs-string">'?'</span>]) &amp;&amp; <span class="hljs-keyword">this</span>.op === <span class="hljs-string">'='</span>) {
      o.scope.declare(left.value, left);
    }
    lefts = Chain(left).cacheReference(o);
    o.level += LEVEL_OP &lt; o.level;
    morph = Binary(<span class="hljs-keyword">this</span>.logic, lefts[<span class="hljs-number">0</span>], (<span class="hljs-keyword">this</span>.logic = <span class="hljs-literal">false</span>, <span class="hljs-keyword">this</span>.left = lefts[<span class="hljs-number">1</span>], <span class="hljs-keyword">this</span>));
    <span class="hljs-keyword">return</span> (morph[<span class="hljs-string">'void'</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'void'</span>], morph).compileNode(o);
  };
  prototype.compileMinMax = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, left, right)</span>{</span>
    <span class="hljs-keyword">var</span> lefts, rites, test, put, ref$;
    lefts = Chain(left).cacheReference(o);
    rites = right.cache(o, <span class="hljs-literal">true</span>);
    test = Binary(<span class="hljs-keyword">this</span>.op.replace(<span class="hljs-string">'?'</span>, <span class="hljs-string">''</span>), lefts[<span class="hljs-number">0</span>], rites[<span class="hljs-number">0</span>]);
    put = Assign(lefts[<span class="hljs-number">1</span>], rites[<span class="hljs-number">1</span>], <span class="hljs-string">':='</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[<span class="hljs-string">'void'</span>] || !o.level) {
      <span class="hljs-keyword">return</span> Parens(Binary(<span class="hljs-string">'||'</span>, test, put)).compile(o);
    }
    ref$ = test.first.cache(o, <span class="hljs-literal">true</span>), test.first = ref$[<span class="hljs-number">0</span>], left = ref$[<span class="hljs-number">1</span>];
    <span class="hljs-keyword">return</span> If(test, left).addElse(put).compileExpression(o);
  };
  prototype.compileDestructuring = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, left)</span>{</span>
    <span class="hljs-keyword">var</span> items, len, ret, rite, that, cache, rref, list, code;
    items = left.items, len = items.length;
    ret = o.level &amp;&amp; !<span class="hljs-keyword">this</span>[<span class="hljs-string">'void'</span>];
    rite = <span class="hljs-keyword">this</span>.right.compile(o, len === <span class="hljs-number">1</span> ? LEVEL_CALL : LEVEL_LIST);
    <span class="hljs-keyword">if</span> (that = left.name) {
      cache = that + <span class="hljs-string">" = "</span> + rite;
      o.scope.declare(rite = that, left);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((ret || len &gt; <span class="hljs-number">1</span>) &amp;&amp; (!ID.test(rite) || left.assigns(rite))) {
      cache = (rref = o.scope.temporary()) + <span class="hljs-string">" = "</span> + rite;
      rite = rref;
    }
    list = <span class="hljs-keyword">this</span>[<span class="hljs-string">"rend"</span> + left.constructor.displayName](o, items, rite);
    <span class="hljs-keyword">if</span> (rref) {
      o.scope.free(rref);
    }
    <span class="hljs-keyword">if</span> (cache) {
      list.unshift(cache);
    }
    <span class="hljs-keyword">if</span> (ret || !list.length) {
      list.push(rite);
    }
    code = list.join(<span class="hljs-string">', '</span>);
    <span class="hljs-keyword">if</span> (list.length &lt; <span class="hljs-number">2</span> || o.level &lt; LEVEL_LIST) {
      <span class="hljs-keyword">return</span> code;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"("</span> + code + <span class="hljs-string">")"</span>;
    }
  };
  prototype.compileSplice = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> ref$, fromExpNode, fromExp, rightNode, right, toExp;
    ref$ = Chain(<span class="hljs-keyword">this</span>.left.from).cacheReference(o), fromExpNode = ref$[<span class="hljs-number">0</span>], fromExp = ref$[<span class="hljs-number">1</span>];
    ref$ = Chain(<span class="hljs-keyword">this</span>.right).cacheReference(o), rightNode = ref$[<span class="hljs-number">0</span>], right = ref$[<span class="hljs-number">1</span>];
    toExp = Binary(<span class="hljs-string">'-'</span>, <span class="hljs-keyword">this</span>.left.to, fromExp);
    <span class="hljs-keyword">return</span> Block([Chain(Var(util(<span class="hljs-string">'splice'</span>))).add(Index(Key(<span class="hljs-string">'apply'</span>), <span class="hljs-string">'.'</span>, <span class="hljs-literal">true</span>)).add(Call([<span class="hljs-keyword">this</span>.left.target, Chain(Arr([fromExpNode, toExp])).add(Index(Key(<span class="hljs-string">'concat'</span>), <span class="hljs-string">'.'</span>, <span class="hljs-literal">true</span>)).add(Call([rightNode]))])), right]).compile(o, LEVEL_LIST);
  };
  prototype.rendArr = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, nodes, rite)</span>{</span>
    <span class="hljs-keyword">var</span> i$, len$, i, node, skip, len, val, ivar, start, inc, rcache, ref$, results$ = [];
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = nodes.length; i$ &lt; len$; ++i$) {
      i = i$;
      node = nodes[i$];
      <span class="hljs-keyword">if</span> (node.isEmpty()) {
        <span class="hljs-keyword">continue</span>;
      }
      <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Splat) {
        len &amp;&amp; node.carp(<span class="hljs-string">'multiple splat in an assignment'</span>);
        skip = (node = node.it).isEmpty();
        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> === (len = nodes.length)) {
          <span class="hljs-keyword">if</span> (skip) {
            <span class="hljs-keyword">break</span>;
          }
          val = Arr.wrap(JS(util(<span class="hljs-string">'slice'</span>) + <span class="hljs-string">'.call('</span> + rite + (i ? <span class="hljs-string">", "</span> + i + <span class="hljs-string">")"</span> : <span class="hljs-string">')'</span>)));
        } <span class="hljs-keyword">else</span> {
          val = ivar = rite + <span class="hljs-string">".length - "</span> + (len - i - <span class="hljs-number">1</span>);
          <span class="hljs-keyword">if</span> (skip &amp;&amp; i + <span class="hljs-number">2</span> === len) {
            <span class="hljs-keyword">continue</span>;
          }
          start = i + <span class="hljs-number">1</span>;
          <span class="hljs-keyword">this</span>.temps = [ivar = o.scope.temporary(<span class="hljs-string">'i'</span>)];
          val = skip
            ? (node = Var(ivar), Var(val))
            : Arr.wrap(JS(i + <span class="hljs-string">" &lt; ("</span> + ivar + <span class="hljs-string">" = "</span> + val + <span class="hljs-string">")\ ? "</span> + util(<span class="hljs-string">'slice'</span>) + <span class="hljs-string">".call("</span> + rite + <span class="hljs-string">", "</span> + i + <span class="hljs-string">", "</span> + ivar + <span class="hljs-string">")\ : ("</span> + ivar + <span class="hljs-string">" = "</span> + i + <span class="hljs-string">", [])"</span>));
        }
      } <span class="hljs-keyword">else</span> {
        (inc = ivar) &amp;&amp; start &lt; i &amp;&amp; (inc += <span class="hljs-string">" + "</span> + (i - start));
        val = Chain(rcache || (rcache = Literal(rite)), [Index(JS(inc || i))]);
      }
      <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Assign) {
        node = Binary(node.op, node.left, node.right, node.logic || <span class="hljs-literal">true</span>);
      }
      results$.push((ref$ = clone$(<span class="hljs-keyword">this</span>), ref$.left = node, ref$.right = val, ref$[<span class="hljs-string">'void'</span>] = <span class="hljs-literal">true</span>, ref$).compile(o, LEVEL_PAREN));
    }
    <span class="hljs-keyword">return</span> results$;
  };
  prototype.rendObj = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, nodes, rite)</span>{</span>
    <span class="hljs-keyword">var</span> i$, len$, node, splat, logic, ref$, key, val, rcache, results$ = [];
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = nodes.length; i$ &lt; len$; ++i$) {
      node = nodes[i$];
      <span class="hljs-keyword">if</span> (splat = node <span class="hljs-keyword">instanceof</span> Splat) {
        node = node.it;
      }
      <span class="hljs-keyword">if</span> (logic = node.getDefault()) {
        node = node.first;
      }
      <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Parens) {
        ref$ = Chain(node.it).cacheReference(o), node = ref$[<span class="hljs-number">0</span>], key = ref$[<span class="hljs-number">1</span>];
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Prop) {
        node = (key = node.key, node).val;
      } <span class="hljs-keyword">else</span> {
        key = node;
      }
      <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Key) {
        node = Var(node.name);
      }
      <span class="hljs-keyword">if</span> (logic) {
        node = (logic.first = node, logic);
      }
      val = Chain(rcache || (rcache = Var(rite)), [Index(key.maybeKey())]);
      <span class="hljs-keyword">if</span> (splat) {
        val = Import(Obj(), val);
      }
      results$.push((ref$ = clone$(<span class="hljs-keyword">this</span>), ref$.left = node, ref$.right = val, ref$[<span class="hljs-string">'void'</span>] = <span class="hljs-literal">true</span>, ref$).compile(o, LEVEL_PAREN));
    }
    <span class="hljs-keyword">return</span> results$;
  };
  <span class="hljs-keyword">return</span> Assign;
}(Node));
exports.Import = Import = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Import, superclass).displayName = <span class="hljs-string">'Import'</span>, Import), superclass).prototype, constructor = Import;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Import</span><span class="hljs-params">(left, right, all)</span>{</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">this</span>$.left = left;
    <span class="hljs-keyword">this</span>$.right = right;
    <span class="hljs-keyword">this</span>$.all = all &amp;&amp; <span class="hljs-string">'All'</span>;
    <span class="hljs-keyword">if</span> (!all &amp;&amp; left <span class="hljs-keyword">instanceof</span> Obj &amp;&amp; right.items) {
      <span class="hljs-keyword">return</span> Obj(left.items.concat(right.asObj().items));
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.children = [<span class="hljs-string">'left'</span>, <span class="hljs-string">'right'</span>];
  prototype.show = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.all;
  };
  prototype.delegate([<span class="hljs-string">'isCallable'</span>, <span class="hljs-string">'isArray'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.left[it]();
  });
  prototype.unfoldSoak = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> left, value, ref$, temps;
    left = <span class="hljs-keyword">this</span>.left;
    <span class="hljs-keyword">if</span> (left <span class="hljs-keyword">instanceof</span> Existence &amp;&amp; !left.negated) {
      <span class="hljs-keyword">if</span> ((left = left.it) <span class="hljs-keyword">instanceof</span> Var) {
        value = (<span class="hljs-keyword">this</span>.left = left).value;
        <span class="hljs-keyword">if</span> (!o.scope.check(value, <span class="hljs-literal">true</span>)) {
          left = JS(<span class="hljs-string">"typeof "</span> + value + <span class="hljs-string">" != 'undefined' &amp;&amp; "</span> + value);
        }
      } <span class="hljs-keyword">else</span> {
        ref$ = left.cache(o), left = ref$[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>.left = ref$[<span class="hljs-number">1</span>], temps = ref$[<span class="hljs-number">2</span>];
      }
      <span class="hljs-keyword">return</span> ref$ = If(left, <span class="hljs-keyword">this</span>), ref$.temps = temps, ref$.soak = <span class="hljs-literal">true</span>, ref$.cond = <span class="hljs-keyword">this</span>.cond, ref$[<span class="hljs-string">'void'</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'void'</span>], ref$;
    }
    <span class="hljs-keyword">return</span> If.unfoldSoak(o, <span class="hljs-keyword">this</span>, <span class="hljs-string">'left'</span>) || (<span class="hljs-keyword">this</span>[<span class="hljs-string">'void'</span>] || !o.level) &amp;&amp; If.unfoldSoak(o, <span class="hljs-keyword">this</span>, <span class="hljs-string">'right'</span>);
  };
  prototype.compileNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> right;
    right = <span class="hljs-keyword">this</span>.right;
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.all) {
      <span class="hljs-keyword">if</span> (right <span class="hljs-keyword">instanceof</span> Chain) {
        right = right.unfoldSoak(o) || right.unfoldAssign(o) || right.expandSlice(o).unwrap();
      }
      <span class="hljs-keyword">if</span> (right <span class="hljs-keyword">instanceof</span> List) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileAssign(o, right.asObj().items);
      }
    }
    <span class="hljs-keyword">return</span> Call.make(Util(<span class="hljs-string">"import"</span> + (<span class="hljs-keyword">this</span>.all || <span class="hljs-string">''</span>)), [<span class="hljs-keyword">this</span>.left, right]).compileNode(o);
  };
  prototype.compileAssign = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, items)</span>{</span>
    <span class="hljs-keyword">var</span> top, reft, ref$, left, delim, space, code, i$, len$, i, node, com, logic, dyna, key, val;
    <span class="hljs-keyword">if</span> (!items.length) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.left.compile(o);
    }
    top = !o.level;
    <span class="hljs-keyword">if</span> (items.length &lt; <span class="hljs-number">2</span> &amp;&amp; (top || <span class="hljs-keyword">this</span>[<span class="hljs-string">'void'</span>] || items[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> Splat)) {
      reft = <span class="hljs-keyword">this</span>.left;
      <span class="hljs-keyword">if</span> (reft.isComplex()) {
        reft = Parens(reft);
      }
    } <span class="hljs-keyword">else</span> {
      ref$ = <span class="hljs-keyword">this</span>.left.cache(o), left = ref$[<span class="hljs-number">0</span>], reft = ref$[<span class="hljs-number">1</span>], <span class="hljs-keyword">this</span>.temps = ref$[<span class="hljs-number">2</span>];
    }
    ref$ = top
      ? [<span class="hljs-string">';'</span>, <span class="hljs-string">'\n'</span> + <span class="hljs-keyword">this</span>.tab]
      : [<span class="hljs-string">','</span>, <span class="hljs-string">' '</span>], delim = ref$[<span class="hljs-number">0</span>], space = ref$[<span class="hljs-number">1</span>];
    delim += space;
    code = <span class="hljs-keyword">this</span>.temps ? left.compile(o, LEVEL_PAREN) + delim : <span class="hljs-string">''</span>;
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = items.length; i$ &lt; len$; ++i$) {
      i = i$;
      node = items[i$];
      i &amp;&amp; (code += com ? space : delim);
      <span class="hljs-keyword">if</span> (com = node.comment) {
        code += node.compile(o);
        <span class="hljs-keyword">continue</span>;
      }
      <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Splat) {
        code += Import(reft, node.it).compile(o);
        <span class="hljs-keyword">continue</span>;
      }
      <span class="hljs-keyword">if</span> (logic = node.getDefault()) {
        node = node.first;
      }
      <span class="hljs-keyword">if</span> (dyna = node <span class="hljs-keyword">instanceof</span> Parens) {
        ref$ = node.it.cache(o, <span class="hljs-literal">true</span>), key = ref$[<span class="hljs-number">0</span>], val = ref$[<span class="hljs-number">1</span>];
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Prop) {
        key = node.key, val = node.val;
        <span class="hljs-keyword">if</span> (node.accessor) {
          <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">instanceof</span> Key) {
            key = JS(<span class="hljs-string">"'"</span> + key.name + <span class="hljs-string">"'"</span>);
          }
          code += <span class="hljs-string">"Object.defineProperty("</span> + reft.compile(o, LEVEL_LIST) + <span class="hljs-string">", "</span> + key.compile(o, LEVEL_LIST) + <span class="hljs-string">", "</span> + node.compileDescriptor(o) + <span class="hljs-string">")"</span>;
          <span class="hljs-keyword">continue</span>;
        }
      } <span class="hljs-keyword">else</span> {
        key = val = node;
      }
      dyna || (key = key.maybeKey());
      logic &amp;&amp; (val = (logic.first = val, logic));
      code += Assign(Chain(reft, [Index(key)]), val).compile(o, LEVEL_PAREN);
    }
    <span class="hljs-keyword">if</span> (top) {
      <span class="hljs-keyword">return</span> code;
    }
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'void'</span>] || node <span class="hljs-keyword">instanceof</span> Splat || (code += (com ? <span class="hljs-string">' '</span> : <span class="hljs-string">', '</span>) + reft.compile(o, LEVEL_PAREN));
    <span class="hljs-keyword">if</span> (o.level &lt; LEVEL_LIST) {
      <span class="hljs-keyword">return</span> code;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"("</span> + code + <span class="hljs-string">")"</span>;
    }
  };
  <span class="hljs-keyword">return</span> Import;
}(Node));
exports.In = In = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(In, superclass).displayName = <span class="hljs-string">'In'</span>, In), superclass).prototype, constructor = In;
  importAll$(prototype, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">In</span><span class="hljs-params">(item, array)</span>{</span>
    <span class="hljs-keyword">this</span>.item = item;
    <span class="hljs-keyword">this</span>.array = array;
  }
  prototype.children = [<span class="hljs-string">'item'</span>, <span class="hljs-string">'array'</span>];
  prototype.compileNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> array, items, code, ref$, sub, ref, cmp, cnj, i$, len$, i, test;
    items = (array = <span class="hljs-keyword">this</span>.array.expandSlice(o).unwrap()).items;
    <span class="hljs-keyword">if</span> (!(array <span class="hljs-keyword">instanceof</span> Arr) || items.length &lt; <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.negated ? <span class="hljs-string">'!'</span> : <span class="hljs-string">''</span>) + <span class="hljs-string">""</span> + util(<span class="hljs-string">'in'</span>) + <span class="hljs-string">"("</span> + <span class="hljs-keyword">this</span>.item.compile(o, LEVEL_LIST) + <span class="hljs-string">", "</span> + array.compile(o, LEVEL_LIST) + <span class="hljs-string">")"</span>;
    }
    code = <span class="hljs-string">''</span>;
    ref$ = <span class="hljs-keyword">this</span>.item.cache(o, <span class="hljs-literal">false</span>, LEVEL_PAREN), sub = ref$[<span class="hljs-number">0</span>], ref = ref$[<span class="hljs-number">1</span>];
    ref$ = <span class="hljs-keyword">this</span>.negated
      ? [<span class="hljs-string">' !== '</span>, <span class="hljs-string">' &amp;&amp; '</span>]
      : [<span class="hljs-string">' === '</span>, <span class="hljs-string">' || '</span>], cmp = ref$[<span class="hljs-number">0</span>], cnj = ref$[<span class="hljs-number">1</span>];
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = items.length; i$ &lt; len$; ++i$) {
      i = i$;
      test = items[i$];
      code &amp;&amp; (code += cnj);
      <span class="hljs-keyword">if</span> (test <span class="hljs-keyword">instanceof</span> Splat) {
        code += (ref$ = <span class="hljs-keyword">new</span> In(Var(ref), test.it), ref$.negated = <span class="hljs-keyword">this</span>.negated, ref$).compile(o, LEVEL_TOP);
        <span class="hljs-keyword">if</span> (!(i || sub === ref)) {
          code = <span class="hljs-string">"("</span> + sub + <span class="hljs-string">", "</span> + code + <span class="hljs-string">")"</span>;
        }
      } <span class="hljs-keyword">else</span> {
        code += (i || sub === ref
          ? ref
          : <span class="hljs-string">"("</span> + sub + <span class="hljs-string">")"</span>) + cmp + test.compile(o, LEVEL_OP + PREC[<span class="hljs-string">'=='</span>]);
      }
    }
    sub === ref || o.scope.free(ref);
    <span class="hljs-keyword">if</span> (o.level &lt; LEVEL_OP + PREC[<span class="hljs-string">'||'</span>]) {
      <span class="hljs-keyword">return</span> code;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"("</span> + code + <span class="hljs-string">")"</span>;
    }
  };
  <span class="hljs-keyword">return</span> In;
}(Node, Negatable));
exports.Existence = Existence = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Existence, superclass).displayName = <span class="hljs-string">'Existence'</span>, Existence), superclass).prototype, constructor = Existence;
  importAll$(prototype, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Existence</span><span class="hljs-params">(it, negated)</span>{</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">this</span>$.it = it;
    <span class="hljs-keyword">this</span>$.negated = negated;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.children = [<span class="hljs-string">'it'</span>];
  prototype.compileNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> node, ref$, code, op, eq;
    node = (ref$ = <span class="hljs-keyword">this</span>.it.unwrap(), ref$.front = <span class="hljs-keyword">this</span>.front, ref$);
    code = node.compile(o, LEVEL_OP + PREC[<span class="hljs-string">'=='</span>]);
    <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Var &amp;&amp; !o.scope.check(code, <span class="hljs-literal">true</span>)) {
      ref$ = <span class="hljs-keyword">this</span>.negated
        ? [<span class="hljs-string">'||'</span>, <span class="hljs-string">'='</span>]
        : [<span class="hljs-string">'&amp;&amp;'</span>, <span class="hljs-string">'!'</span>], op = ref$[<span class="hljs-number">0</span>], eq = ref$[<span class="hljs-number">1</span>];
      code = <span class="hljs-string">"typeof "</span> + code + <span class="hljs-string">" "</span> + eq + <span class="hljs-string">"= 'undefined' "</span> + op + <span class="hljs-string">" "</span> + code + <span class="hljs-string">" "</span> + eq + <span class="hljs-string">"== null"</span>;
    } <span class="hljs-keyword">else</span> {
      code += <span class="hljs-string">" "</span> + (op = <span class="hljs-keyword">this</span>.negated ? <span class="hljs-string">'=='</span> : <span class="hljs-string">'!='</span>) + <span class="hljs-string">" null"</span>;
    }
    <span class="hljs-keyword">if</span> (o.level &lt; LEVEL_OP + PREC[op]) {
      <span class="hljs-keyword">return</span> code;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"("</span> + code + <span class="hljs-string">")"</span>;
    }
  };
  <span class="hljs-keyword">return</span> Existence;
}(Node, Negatable));
exports.Fun = Fun = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Fun, superclass).displayName = <span class="hljs-string">'Fun'</span>, Fun), superclass).prototype, constructor = Fun;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fun</span><span class="hljs-params">(params, body, bound, curried, hushed, generator)</span>{</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">this</span>$.params = params || [];
    <span class="hljs-keyword">this</span>$.body = body || Block();
    <span class="hljs-keyword">this</span>$.bound = bound &amp;&amp; <span class="hljs-string">'this$'</span>;
    <span class="hljs-keyword">this</span>$.curried = curried || <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>$.hushed = hushed != <span class="hljs-literal">null</span> ? hushed : <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>$.generator = generator != <span class="hljs-literal">null</span> ? generator : <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.children = [<span class="hljs-string">'params'</span>, <span class="hljs-string">'body'</span>];
  prototype.show = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> that;
    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">this</span>.name] + [(that = <span class="hljs-keyword">this</span>.bound) ? <span class="hljs-string">"~"</span> + that : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>];
  };
  prototype.named = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name = it, <span class="hljs-keyword">this</span>.statement = <span class="hljs-literal">true</span>, <span class="hljs-keyword">this</span>;
  };
  prototype.isCallable = YES;
  prototype.isStatement = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> !!<span class="hljs-keyword">this</span>.statement;
  };
  prototype.traverseChildren = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg$, xscope)</span>{</span>
    <span class="hljs-keyword">if</span> (xscope) {
      <span class="hljs-keyword">return</span> superclass.prototype.traverseChildren.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }
  };
  prototype.makeReturn = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.statement) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.returns = <span class="hljs-literal">true</span>, <span class="hljs-keyword">this</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> superclass.prototype.makeReturn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }
  };
  prototype.ripName = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">this</span>.name || (<span class="hljs-keyword">this</span>.name = it.varName());
  };
  prototype.compileNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> pscope, sscope, scope, that, inLoop, ref$, body, name, tab, code, curryCodeCheck, <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span>;
    pscope = o.scope;
    sscope = pscope.shared || pscope;
    scope = o.scope = <span class="hljs-keyword">this</span>.body.scope = <span class="hljs-keyword">new</span> Scope(<span class="hljs-keyword">this</span>.wrapper ? pscope : sscope, <span class="hljs-keyword">this</span>.wrapper &amp;&amp; sscope);
    scope.fun = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">if</span> (that = <span class="hljs-keyword">this</span>.proto) {
      scope.assign(<span class="hljs-string">'prototype'</span>, that.compile(o) + <span class="hljs-string">".prototype"</span>);
    }
    <span class="hljs-keyword">if</span> (that = <span class="hljs-keyword">this</span>.cname) {
      scope.assign(<span class="hljs-string">'constructor'</span>, that);
    }
    <span class="hljs-keyword">if</span> (inLoop = (ref$ = o.loop, <span class="hljs-keyword">delete</span> o.loop, ref$)) {
      o.indent = <span class="hljs-keyword">this</span>.tab = <span class="hljs-string">''</span>;
    }
    o.indent += TAB;
    body = <span class="hljs-keyword">this</span>.body, name = <span class="hljs-keyword">this</span>.name, tab = <span class="hljs-keyword">this</span>.tab;
    code = <span class="hljs-string">'function'</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.generator) {
      <span class="hljs-keyword">this</span>.ctor &amp;&amp; <span class="hljs-keyword">this</span>.carp(<span class="hljs-string">"a constructor can't be a generator"</span>);
      <span class="hljs-keyword">this</span>.hushed &amp;&amp; <span class="hljs-keyword">this</span>.carp(<span class="hljs-string">"a generator is hushed by default"</span>);
      code += <span class="hljs-string">'*'</span>;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.bound === <span class="hljs-string">'this$'</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.ctor) {
        scope.assign(<span class="hljs-string">'this$'</span>, <span class="hljs-string">'this instanceof ctor$ ? this : new ctor$'</span>);
        body.lines.push(Return(Literal(<span class="hljs-string">'this$'</span>)));
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (that = (ref$ = sscope.fun) != <span class="hljs-literal">null</span> ? ref$.bound : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>) {
        <span class="hljs-keyword">this</span>.bound = that;
      } <span class="hljs-keyword">else</span> {
        sscope.assign(<span class="hljs-string">'this$'</span>, <span class="hljs-string">'this'</span>);
      }
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.statement) {
      name || <span class="hljs-keyword">this</span>.carp(<span class="hljs-string">'nameless function declaration'</span>);
      pscope === o.block.scope || <span class="hljs-keyword">this</span>.carp(<span class="hljs-string">'misplaced function declaration'</span>);
      <span class="hljs-keyword">this</span>.accessor &amp;&amp; <span class="hljs-keyword">this</span>.carp(<span class="hljs-string">'named accessor'</span>);
      pscope.add(name, <span class="hljs-string">'function'</span>, <span class="hljs-keyword">this</span>);
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.statement || name &amp;&amp; <span class="hljs-keyword">this</span>.labeled) {
      code += <span class="hljs-string">' '</span> + scope.add(name, <span class="hljs-string">'function'</span>, <span class="hljs-keyword">this</span>);
    }
    <span class="hljs-keyword">this</span>.hushed || <span class="hljs-keyword">this</span>.ctor || <span class="hljs-keyword">this</span>.newed || <span class="hljs-keyword">this</span>.generator || body.makeReturn();
    code += <span class="hljs-string">"("</span> + <span class="hljs-keyword">this</span>.compileParams(o, scope) + <span class="hljs-string">"){"</span>;
    <span class="hljs-keyword">if</span> (that = body.compileWithDeclarations(o)) {
      code += <span class="hljs-string">"\n"</span> + that + <span class="hljs-string">"\n"</span> + tab;
    }
    code += <span class="hljs-string">'}'</span>;
    curryCodeCheck = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>$.curried &amp;&amp; <span class="hljs-keyword">this</span>$.hasSplats) {
        <span class="hljs-keyword">this</span>$.carp(<span class="hljs-string">'cannot curry a function with a variable number of arguments'</span>);
      }
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>$.curried &amp;&amp; <span class="hljs-keyword">this</span>$.params.length &gt; <span class="hljs-number">1</span> &amp;&amp; !<span class="hljs-keyword">this</span>$.classBound) {
        <span class="hljs-keyword">return</span> (util(<span class="hljs-string">'curry'</span>) + <span class="hljs-string">""</span>) + (<span class="hljs-keyword">this</span>$.bound
          ? <span class="hljs-string">"(("</span> + code + <span class="hljs-string">"), true)"</span>
          : <span class="hljs-string">"("</span> + code + <span class="hljs-string">")"</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> code;
      }
    };
    <span class="hljs-keyword">if</span> (inLoop) {
      <span class="hljs-keyword">return</span> pscope.assign(pscope.temporary(<span class="hljs-string">'fn'</span>), curryCodeCheck());
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.returns) {
      code += <span class="hljs-string">"\n"</span> + tab + <span class="hljs-string">"return "</span> + name + <span class="hljs-string">";"</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.bound &amp;&amp; <span class="hljs-keyword">this</span>.ctor) {
      code += <span class="hljs-string">' function ctor$(){} ctor$.prototype = prototype;'</span>;
    }
    code = curryCodeCheck();
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.front &amp;&amp; !<span class="hljs-keyword">this</span>.statement) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"("</span> + code + <span class="hljs-string">")"</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> code;
    }
  };
  prototype.compileParams = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, scope)</span>{</span>
    <span class="hljs-keyword">var</span> params, length, body, i$, p, len$, i, splace, rest, that, names, assigns, dic, vr, df, unaries, hasUnary, v, ref$, ref1$;
    params = <span class="hljs-keyword">this</span>.params, length = params.length, body = <span class="hljs-keyword">this</span>.body;
    <span class="hljs-keyword">for</span> (i$ = params.length - <span class="hljs-number">1</span>; i$ &gt;= <span class="hljs-number">0</span>; --i$) {
      p = params[i$];
      <span class="hljs-keyword">if</span> (!(p.isEmpty() || p.filler)) {
        <span class="hljs-keyword">break</span>;
      }
      --params.length;
    }
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = params.length; i$ &lt; len$; ++i$) {
      i = i$;
      p = params[i$];
      <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> Splat) {
        <span class="hljs-keyword">this</span>.hasSplats = <span class="hljs-literal">true</span>;
        splace = i;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.op === <span class="hljs-string">'='</span>) {
        params[i] = Binary(p.logic || <span class="hljs-string">'?'</span>, p.left, p.right);
      }
    }
    <span class="hljs-keyword">if</span> (splace != <span class="hljs-literal">null</span>) {
      rest = params.splice(splace, <span class="hljs-number">9e9</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.accessor) {
      <span class="hljs-keyword">if</span> (that = params[<span class="hljs-number">1</span>]) {
        that.carp(<span class="hljs-string">'excess accessor parameter'</span>);
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(length || <span class="hljs-keyword">this</span>.wrapper)) {
      <span class="hljs-keyword">if</span> (body.traverseChildren(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
        <span class="hljs-keyword">return</span> it.value === <span class="hljs-string">'it'</span> || <span class="hljs-literal">null</span>;
      })) {
        params[<span class="hljs-number">0</span>] = Var(<span class="hljs-string">'it'</span>);
      }
    }
    names = [];
    assigns = [];
    <span class="hljs-keyword">if</span> (params.length) {
      dic = {};
      <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = params.length; i$ &lt; len$; ++i$) {
        p = params[i$];
        vr = p;
        <span class="hljs-keyword">if</span> (df = vr.getDefault()) {
          vr = vr.first;
        }
        <span class="hljs-keyword">if</span> (vr.isEmpty()) {
          vr = Var(scope.temporary(<span class="hljs-string">'arg'</span>));
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vr.value === <span class="hljs-string">'..'</span>) {
          vr = Var(o.ref = scope.temporary());
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(vr <span class="hljs-keyword">instanceof</span> Var)) {
          unaries = [];
          <span class="hljs-keyword">while</span> (vr <span class="hljs-keyword">instanceof</span> Unary) {
            hasUnary = <span class="hljs-literal">true</span>;
            unaries.push(vr);
            vr = vr.it;
          }
          v = Var((ref1$ = (ref$ = vr.it || vr).name, <span class="hljs-keyword">delete</span> ref$.name, ref1$) || vr.varName() || scope.temporary(<span class="hljs-string">'arg'</span>));
          assigns.push(Assign(vr, (fn$())));
          vr = v;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (df) {
          assigns.push(Assign(vr, p.second, <span class="hljs-string">'='</span>, p.op, <span class="hljs-literal">true</span>));
        }
        names.push(scope.add(vr.value, <span class="hljs-string">'arg'</span>, p));
      }
    }
    <span class="hljs-keyword">if</span> (rest) {
      <span class="hljs-keyword">while</span> (splace--) {
        rest.unshift(Arr());
      }
      assigns.push(Assign(Arr(rest), Literal(<span class="hljs-string">'arguments'</span>)));
    }
    <span class="hljs-keyword">if</span> (assigns.length) {
      (ref$ = <span class="hljs-keyword">this</span>.body).prepend.apply(ref$, assigns);
    }
    <span class="hljs-keyword">return</span> names.join(<span class="hljs-string">', '</span>);
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn$</span><span class="hljs-params">()</span>{</span>
      <span class="hljs-keyword">switch</span> (<span class="hljs-literal">false</span>) {
      <span class="hljs-keyword">case</span> !df:
        <span class="hljs-keyword">return</span> Binary(p.op, v, p.second);
      <span class="hljs-keyword">case</span> !hasUnary:
        <span class="hljs-keyword">return</span> fold(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x, y)</span>{</span>
          y.it = x;
          <span class="hljs-keyword">return</span> y;
        }, v, unaries.reverse());
      <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">return</span> v;
      }
    }
  };
  <span class="hljs-keyword">return</span> Fun;
}(Node));
exports.Class = Class = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Class, superclass).displayName = <span class="hljs-string">'Class'</span>, Class), superclass).prototype, constructor = Class;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Class</span><span class="hljs-params">(arg$)</span>{</span>
    <span class="hljs-keyword">var</span> body;
    <span class="hljs-keyword">this</span>.title = arg$.title, <span class="hljs-keyword">this</span>.sup = arg$.sup, <span class="hljs-keyword">this</span>.mixins = arg$.mixins, body = arg$.body;
    <span class="hljs-keyword">this</span>.fun = Fun([], body);
  }
  prototype.children = [<span class="hljs-string">'title'</span>, <span class="hljs-string">'sup'</span>, <span class="hljs-string">'mixins'</span>, <span class="hljs-string">'fun'</span>];
  prototype.isCallable = YES;
  prototype.ripName = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">this</span>.name = it.varName();
  };
  prototype.compile = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, level)</span>{</span>
    <span class="hljs-keyword">var</span> fun, body, lines, title, boundFuncs, curriedBoundFuncs, decl, name, proto, ctorName, ctor, ctorPlace, importProtoObj, i$, len$, i, node, f, vname, args, that, imports, ref$, res$, clas;
    fun = <span class="hljs-keyword">this</span>.fun, body = fun.body, lines = body.lines, title = <span class="hljs-keyword">this</span>.title;
    boundFuncs = [];
    curriedBoundFuncs = [];
    decl = title != <span class="hljs-literal">null</span> ? title.varName() : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>;
    name = decl || <span class="hljs-keyword">this</span>.name;
    <span class="hljs-keyword">if</span> (ID.test(name || <span class="hljs-string">''</span>)) {
      fun.cname = name;
    } <span class="hljs-keyword">else</span> {
      name = <span class="hljs-string">'constructor'</span>;
    }
    proto = Var(<span class="hljs-string">'prototype'</span>);
    ctorName = <span class="hljs-string">'constructor$$'</span>;
    importProtoObj = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node, i)</span>{</span>
      <span class="hljs-keyword">var</span> j, prop, key, i$, ref$, len$, v;
      j = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (; j &lt; node.items.length; j++) {
        prop = node.items[j];
        key = prop.key;
        <span class="hljs-keyword">if</span> ((key <span class="hljs-keyword">instanceof</span> Key &amp;&amp; key.name === ctorName) || (key <span class="hljs-keyword">instanceof</span> Literal &amp;&amp; key.value === <span class="hljs-string">"'"</span> + ctorName + <span class="hljs-string">"'"</span>)) {
          <span class="hljs-keyword">if</span> (ctor) {
            node.carp(<span class="hljs-string">'redundant constructor'</span>);
          }
          ctor = prop.val;
          node.items.splice(j--, <span class="hljs-number">1</span>);
          ctorPlace = i;
        }
        <span class="hljs-keyword">if</span> (!(prop.val <span class="hljs-keyword">instanceof</span> Fun || prop.accessor)) {
          <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-keyword">if</span> (key.isComplex()) {
          key = Var(o.scope.temporary(<span class="hljs-string">'key'</span>));
          prop.key = Assign(key, prop.key);
        }
        <span class="hljs-keyword">if</span> (prop.val.bound) {
          <span class="hljs-keyword">if</span> (prop.val.curried) {
            curriedBoundFuncs.push(prop.key);
          } <span class="hljs-keyword">else</span> {
            boundFuncs.push(prop.key);
          }
          prop.val.bound = <span class="hljs-literal">false</span>;
          prop.val.classBound = <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = [].concat(prop.val)).length; i$ &lt; len$; ++i$) {
          v = ref$[i$];
          v.meth = key;
        }
      }
      <span class="hljs-keyword">if</span> (node.items.length) {
        <span class="hljs-keyword">return</span> Import(proto, node);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> Literal(<span class="hljs-string">'void'</span>);
      }
    };
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = lines.length; i$ &lt; len$; ++i$) {
      i = i$;
      node = lines[i$];
      <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Obj) {
        lines[i] = importProtoObj(node, i);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Fun &amp;&amp; !node.statement) {
        ctor &amp;&amp; node.carp(<span class="hljs-string">'redundant constructor'</span>);
        ctor = node;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Assign &amp;&amp; node.left <span class="hljs-keyword">instanceof</span> Chain &amp;&amp; node.left.head.value === <span class="hljs-string">'this'</span> &amp;&amp; node.right <span class="hljs-keyword">instanceof</span> Fun) {
        node.right.stat = node.left.tails[<span class="hljs-number">0</span>].key;
      } <span class="hljs-keyword">else</span> {
        node.traverseChildren(fn$);
      }
    }
    ctor || (ctor = lines[lines.length] = <span class="hljs-keyword">this</span>.sup
      ? Fun([], Block(Chain(<span class="hljs-keyword">new</span> Super).add(Call([Splat(Literal(<span class="hljs-string">'arguments'</span>))]))))
      : Fun());
    <span class="hljs-keyword">if</span> (!(ctor <span class="hljs-keyword">instanceof</span> Fun)) {
      lines.splice(ctorPlace + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, Assign(Var(ctorName), ctor));
      lines.unshift(ctor = Fun([], Block(Return(Chain(Var(ctorName)).add(Call([Splat(<span class="hljs-string">'arguments'</span>, <span class="hljs-literal">true</span>)]))))));
    }
    ctor.name = name;
    ctor.ctor = <span class="hljs-literal">true</span>;
    ctor.statement = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = boundFuncs.length; i$ &lt; len$; ++i$) {
      f = boundFuncs[i$];
      ctor.body.lines.unshift(Assign(Chain(Literal(<span class="hljs-string">'this'</span>)).add(Index(f)), Chain(Var(util(<span class="hljs-string">'bind'</span>))).add(Call([Literal(<span class="hljs-string">'this'</span>), Literal(<span class="hljs-string">"'"</span> + f.name + <span class="hljs-string">"'"</span>), Var(<span class="hljs-string">'prototype'</span>)]))));
    }
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = curriedBoundFuncs.length; i$ &lt; len$; ++i$) {
      f = curriedBoundFuncs[i$];
      ctor.body.lines.unshift(Assign(Chain(Literal(<span class="hljs-string">'this'</span>)).add(Index(Key(<span class="hljs-string">"_"</span> + f.name))), Chain(Var(util(<span class="hljs-string">'curry'</span>))).add(Call([Chain(Var(<span class="hljs-string">'prototype'</span>)).add(Index(f)), Var(<span class="hljs-string">'true'</span>)]))), Assign(Chain(Literal(<span class="hljs-string">'this'</span>)).add(Index(f)), Chain(Var(util(<span class="hljs-string">'bind'</span>))).add(Call([Literal(<span class="hljs-string">'this'</span>), Literal(<span class="hljs-string">"'_"</span> + f.name + <span class="hljs-string">"'"</span>)]))));
    }
    lines.push(vname = fun.proto = Var(fun.bound = name));
    args = [];
    <span class="hljs-keyword">if</span> (that = <span class="hljs-keyword">this</span>.sup) {
      args.push(that);
      imports = Chain(Import(Literal(<span class="hljs-string">'this'</span>), Var(<span class="hljs-string">'superclass'</span>)));
      fun.proto = Util.Extends(fun.cname ? Block([Assign(imports.add(Index(Key(<span class="hljs-string">'displayName'</span>))), Literal(<span class="hljs-string">"'"</span> + name + <span class="hljs-string">"'"</span>)), Literal(name)]) : imports, (ref$ = fun.params)[ref$.length] = Var(<span class="hljs-string">'superclass'</span>));
    }
    <span class="hljs-keyword">if</span> (that = <span class="hljs-keyword">this</span>.mixins) {
      res$ = [];
      <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = that.length; i$ &lt; len$; ++i$) {
        args[args.length] = that[i$];
        res$.push(Import(proto, JS(<span class="hljs-string">"arguments["</span> + (args.length - <span class="hljs-number">1</span>) + <span class="hljs-string">"]"</span>), <span class="hljs-literal">true</span>));
      }
      imports = res$;
      body.prepend.apply(body, imports);
    }
    <span class="hljs-keyword">if</span> (fun.cname &amp;&amp; !<span class="hljs-keyword">this</span>.sup) {
      body.prepend(Literal(name + <span class="hljs-string">".displayName = '"</span> + name + <span class="hljs-string">"'"</span>));
    }
    clas = Parens(Call.make(fun, args), <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">if</span> (decl &amp;&amp; title.isComplex()) {
      clas = Assign(vname, clas);
    }
    <span class="hljs-keyword">if</span> (title) {
      clas = Assign(title, clas);
    }
    <span class="hljs-keyword">return</span> clas.compile(o, level);
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn$</span><span class="hljs-params">(it)</span>{</span>
      <span class="hljs-keyword">var</span> i$, ref$, len$, k, child;
      <span class="hljs-keyword">if</span> (it <span class="hljs-keyword">instanceof</span> Block) {
        <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = it.lines).length; i$ &lt; len$; ++i$) {
          k = i$;
          child = ref$[i$];
          <span class="hljs-keyword">if</span> (child <span class="hljs-keyword">instanceof</span> Obj) {
            it.lines[k] = importProtoObj(child, i);
          }
        }
      }
    }
  };
  <span class="hljs-keyword">return</span> Class;
}(Node));
exports.Super = Super = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Super, superclass).displayName = <span class="hljs-string">'Super'</span>, Super), superclass).prototype, constructor = Super;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Super</span><span class="hljs-params">()</span>{</span>}
  prototype.isCallable = YES;
  prototype.compile = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> scope, that, result, ref$;
    scope = o.scope;
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.sproto) {
      <span class="hljs-keyword">for</span> (; that = !scope.get(<span class="hljs-string">'superclass'</span>) &amp;&amp; scope.fun; scope = scope.parent) {
        result = that;
        <span class="hljs-keyword">if</span> (that = result.meth) {
          <span class="hljs-keyword">return</span> <span class="hljs-string">'superclass.prototype'</span> + Index(that).compile(o);
        }
        <span class="hljs-keyword">if</span> (that = result.stat) {
          <span class="hljs-keyword">return</span> <span class="hljs-string">'superclass'</span> + Index(that).compile(o);
        }
        <span class="hljs-keyword">if</span> (that = scope.fun.inClass) {
          <span class="hljs-keyword">return</span> that + <span class="hljs-string">".superclass.prototype."</span> + scope.fun.name;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (that = scope.fun.inClassStatic) {
          <span class="hljs-keyword">return</span> that + <span class="hljs-string">".superclass."</span> + scope.fun.name;
        }
      }
      <span class="hljs-keyword">if</span> (that = (ref$ = o.scope.fun) != <span class="hljs-literal">null</span> ? ref$.name : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>) {
        <span class="hljs-keyword">return</span> that + <span class="hljs-string">".superclass"</span>;
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-string">'superclass'</span>;
  };
  <span class="hljs-keyword">return</span> Super;
}(Node));
exports.Parens = Parens = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Parens, superclass).displayName = <span class="hljs-string">'Parens'</span>, Parens), superclass).prototype, constructor = Parens;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parens</span><span class="hljs-params">(it, keep, string)</span>{</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">this</span>$.it = it;
    <span class="hljs-keyword">this</span>$.keep = keep;
    <span class="hljs-keyword">this</span>$.string = string;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.children = [<span class="hljs-string">'it'</span>];
  prototype.show = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.string &amp;&amp; <span class="hljs-string">'""'</span>;
  };
  prototype.delegate([<span class="hljs-string">'isComplex'</span>, <span class="hljs-string">'isCallable'</span>, <span class="hljs-string">'isArray'</span>, <span class="hljs-string">'isRegex'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.it[it]();
  });
  prototype.isString = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.string || <span class="hljs-keyword">this</span>.it.isString();
  };
  prototype.unparen = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.keep) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.it.unparen();
    }
  };
  prototype.compile = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, level)</span>{</span>
    <span class="hljs-keyword">var</span> it;
    level == <span class="hljs-literal">null</span> &amp;&amp; (level = o.level);
    it = <span class="hljs-keyword">this</span>.it;
    it.cond || (it.cond = <span class="hljs-keyword">this</span>.cond), it[<span class="hljs-string">'void'</span>] || (it[<span class="hljs-string">'void'</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'void'</span>]);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.calling &amp;&amp; (!level || <span class="hljs-keyword">this</span>[<span class="hljs-string">'void'</span>])) {
      it.head.hushed = <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span>.keep || <span class="hljs-keyword">this</span>.newed || level &gt;= LEVEL_OP + PREC[it.op])) {
      <span class="hljs-keyword">return</span> (it.front = <span class="hljs-keyword">this</span>.front, it).compile(o, level || LEVEL_PAREN);
    }
    <span class="hljs-keyword">if</span> (it.isStatement()) {
      <span class="hljs-keyword">return</span> it.compileClosure(o);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"("</span> + it.compile(o, LEVEL_PAREN) + <span class="hljs-string">")"</span>;
    }
  };
  <span class="hljs-keyword">return</span> Parens;
}(Node));
exports.Splat = Splat = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> ref$, prototype = extend$((import$(Splat, superclass).displayName = <span class="hljs-string">'Splat'</span>, Splat), superclass).prototype, constructor = Splat;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Splat</span><span class="hljs-params">(it, filler)</span>{</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">this</span>$.it = it;
    <span class="hljs-keyword">this</span>$.filler = filler;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  ref$ = Parens.prototype, prototype.children = ref$.children, prototype.isComplex = ref$.isComplex;
  prototype.isAssignable = YES;
  prototype.assigns = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.it.assigns(it);
  };
  prototype.compile = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.carp(<span class="hljs-string">'invalid splat'</span>);
  };
  Splat.compileArray = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, list, apply)</span>{</span>
    <span class="hljs-keyword">var</span> index, i$, len$, node, args, atoms, ref$;
    expand(list);
    index = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = list.length; i$ &lt; len$; ++i$) {
      node = list[i$];
      <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Splat) {
        <span class="hljs-keyword">break</span>;
      }
      ++index;
    }
    <span class="hljs-keyword">if</span> (index &gt;= list.length) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
    }
    <span class="hljs-keyword">if</span> (!list[<span class="hljs-number">1</span>]) {
      <span class="hljs-keyword">return</span> (apply ? <span class="hljs-built_in">Object</span> : ensureArray)(list[<span class="hljs-number">0</span>].it).compile(o, LEVEL_LIST);
    }
    args = [];
    atoms = [];
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = list.splice(index, <span class="hljs-number">9e9</span>)).length; i$ &lt; len$; ++i$) {
      node = ref$[i$];
      <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Splat) {
        <span class="hljs-keyword">if</span> (atoms.length) {
          args.push(Arr(atoms.splice(<span class="hljs-number">0</span>, <span class="hljs-number">9e9</span>)));
        }
        args.push(ensureArray(node.it));
      } <span class="hljs-keyword">else</span> {
        atoms.push(node);
      }
    }
    <span class="hljs-keyword">if</span> (atoms.length) {
      args.push(Arr(atoms));
    }
    <span class="hljs-keyword">return</span> (index
      ? Arr(list)
      : args.shift()).compile(o, LEVEL_CALL) + (<span class="hljs-string">".concat("</span> + List.compile(o, args) + <span class="hljs-string">")"</span>);
  };
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expand</span><span class="hljs-params">(nodes)</span>{</span>
    <span class="hljs-keyword">var</span> index, node, it;
    index = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (node = nodes[++index]) {
      <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Splat) {
        it = node.it;
        <span class="hljs-keyword">if</span> (it.isEmpty()) {
          nodes.splice(index--, <span class="hljs-number">1</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (it <span class="hljs-keyword">instanceof</span> Arr) {
          nodes.splice.apply(nodes, [index, <span class="hljs-number">1</span>].concat(slice$.call(expand(it.items))));
          index += it.items.length - <span class="hljs-number">1</span>;
        }
      }
    }
    <span class="hljs-keyword">return</span> nodes;
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ensureArray</span><span class="hljs-params">(node)</span>{</span>
    <span class="hljs-keyword">if</span> (node.isArray()) {
      <span class="hljs-keyword">return</span> node;
    }
    <span class="hljs-keyword">return</span> Call.make(JS(util(<span class="hljs-string">'slice'</span>) + <span class="hljs-string">'.call'</span>), [node]);
  }
  <span class="hljs-keyword">return</span> Splat;
}(Node));
exports.Jump = Jump = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Jump, superclass).displayName = <span class="hljs-string">'Jump'</span>, Jump), superclass).prototype, constructor = Jump;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Jump</span><span class="hljs-params">(verb, label)</span>{</span>
    <span class="hljs-keyword">this</span>.verb = verb;
    <span class="hljs-keyword">this</span>.label = label;
  }
  prototype.show = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> that;
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.verb || <span class="hljs-string">''</span>) + ((that = <span class="hljs-keyword">this</span>.label) ? <span class="hljs-string">' '</span> + that : <span class="hljs-string">''</span>);
  };
  prototype.isStatement = YES;
  prototype.makeReturn = THIS;
  prototype.getJump = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ctx)</span>{</span>
    <span class="hljs-keyword">var</span> that, ref$;
    ctx || (ctx = {});
    <span class="hljs-keyword">if</span> (!ctx[<span class="hljs-keyword">this</span>.verb]) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
    <span class="hljs-keyword">if</span> (that = <span class="hljs-keyword">this</span>.label) {
      <span class="hljs-keyword">return</span> !<span class="hljs-keyword">in</span>$(that, (ref$ = ctx.labels) != <span class="hljs-literal">null</span>
        ? ref$
        : ctx.labels = []) &amp;&amp; <span class="hljs-keyword">this</span>;
    }
  };
  prototype.compileNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> that, ref$;
    <span class="hljs-keyword">if</span> (that = <span class="hljs-keyword">this</span>.label) {
      <span class="hljs-keyword">in</span>$(that, (ref$ = o.labels) != <span class="hljs-literal">null</span>
        ? ref$
        : o.labels = []) || <span class="hljs-keyword">this</span>.carp(<span class="hljs-string">"unknown label \""</span> + that + <span class="hljs-string">"\""</span>);
    } <span class="hljs-keyword">else</span> {
      o[<span class="hljs-keyword">this</span>.verb] || <span class="hljs-keyword">this</span>.carp(<span class="hljs-string">"stray "</span> + <span class="hljs-keyword">this</span>.verb);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.show() + <span class="hljs-string">';'</span>;
  };
  Jump.extended = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(sub)</span>{</span>
    sub.prototype.children = [<span class="hljs-string">'it'</span>];
    <span class="hljs-keyword">this</span>[sub.displayName.toLowerCase()] = sub;
  };
  <span class="hljs-keyword">return</span> Jump;
}(Node));
exports.Throw = Throw = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Throw, superclass).displayName = <span class="hljs-string">'Throw'</span>, Throw), superclass).prototype, constructor = Throw;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Throw</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">this</span>$.it = it;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.getJump = VOID;
  prototype.compileNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> ref$;
    <span class="hljs-keyword">return</span> <span class="hljs-string">"throw "</span> + (((ref$ = <span class="hljs-keyword">this</span>.it) != <span class="hljs-literal">null</span> ? ref$.compile(o, LEVEL_PAREN) : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>) || <span class="hljs-string">'null'</span>) + <span class="hljs-string">";"</span>;
  };
  <span class="hljs-keyword">return</span> Throw;
}(Jump));
exports.Return = Return = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Return, superclass).displayName = <span class="hljs-string">'Return'</span>, Return), superclass).prototype, constructor = Return;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Return</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">if</span> (it &amp;&amp; it.value !== <span class="hljs-string">'void'</span>) {
      <span class="hljs-keyword">this</span>$.it = it;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.getJump = THIS;
  prototype.compileNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> that;
    <span class="hljs-keyword">return</span> <span class="hljs-string">"return"</span> + ((that = <span class="hljs-keyword">this</span>.it) ? <span class="hljs-string">' '</span> + that.compile(o, LEVEL_PAREN) : <span class="hljs-string">''</span>) + <span class="hljs-string">";"</span>;
  };
  <span class="hljs-keyword">return</span> Return;
}(Jump));
exports.While = While = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(While, superclass).displayName = <span class="hljs-string">'While'</span>, While), superclass).prototype, constructor = While;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">While</span><span class="hljs-params">(test, un, mode)</span>{</span>
    <span class="hljs-keyword">this</span>.un = un;
    mode &amp;&amp; (mode <span class="hljs-keyword">instanceof</span> Node
      ? <span class="hljs-keyword">this</span>.update = mode
      : <span class="hljs-keyword">this</span>.post = <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.post || test.value !== <span class="hljs-string">''</span> + !un) {
      <span class="hljs-keyword">this</span>.test = test;
    }
  }
  prototype.children = [<span class="hljs-string">'test'</span>, <span class="hljs-string">'body'</span>, <span class="hljs-string">'update'</span>, <span class="hljs-string">'else'</span>];
  prototype.aSource = <span class="hljs-string">'test'</span>;
  prototype.aTargets = [<span class="hljs-string">'body'</span>, <span class="hljs-string">'update'</span>];
  prototype.show = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">this</span>.un ? <span class="hljs-string">'!'</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>, <span class="hljs-keyword">this</span>.post ? <span class="hljs-string">'do'</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>].join(<span class="hljs-string">''</span>);
  };
  prototype.isStatement = prototype.isArray = YES;
  prototype.makeComprehension = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(toAdd, loops)</span>{</span>
    <span class="hljs-keyword">this</span>.isComprehension = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">while</span> (loops.length) {
      toAdd = loops.pop().addBody(Block(toAdd));
      <span class="hljs-keyword">if</span> (!toAdd.isComprehension) {
        toAdd.inComprehension = <span class="hljs-literal">true</span>;
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.addBody(Block(toAdd));
  };
  prototype.getJump = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ctx)</span>{</span>
    <span class="hljs-keyword">var</span> i$, ref$, ref1$, len$, node;
    ctx || (ctx = {});
    ctx[<span class="hljs-string">'continue'</span>] = <span class="hljs-literal">true</span>;
    ctx[<span class="hljs-string">'break'</span>] = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = ((ref1$ = <span class="hljs-keyword">this</span>.body) != <span class="hljs-literal">null</span> ? ref1$.lines : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>) || []).length; i$ &lt; len$; ++i$) {
      node = ref$[i$];
      <span class="hljs-keyword">if</span> (node.getJump(ctx)) {
        <span class="hljs-keyword">return</span> node;
      }
    }
  };
  prototype.addBody = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(body)</span>{</span>
    <span class="hljs-keyword">var</span> top;
    <span class="hljs-keyword">this</span>.body = body;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.guard) {
      <span class="hljs-keyword">this</span>.body = Block(If(<span class="hljs-keyword">this</span>.guard, <span class="hljs-keyword">this</span>.body));
    }
    top = <span class="hljs-keyword">this</span>.body.lines[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">if</span> ((top != <span class="hljs-literal">null</span> ? top.verb : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>) === <span class="hljs-string">'continue'</span> &amp;&amp; !top.label) {
      <span class="hljs-keyword">this</span>.body.lines.length = <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  prototype.addGuard = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(guard)</span>{</span>
    <span class="hljs-keyword">this</span>.guard = guard;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  prototype.addObjComp = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(objComp)</span>{</span>
    <span class="hljs-keyword">this</span>.objComp = objComp != <span class="hljs-literal">null</span> ? objComp : <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  prototype.makeReturn = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">var</span> last, ref$, ref1$, ref2$;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hasReturned) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
    <span class="hljs-keyword">if</span> (it) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.objComp) {
        <span class="hljs-keyword">this</span>.body = Block(<span class="hljs-keyword">this</span>.body.makeObjReturn(it));
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.guard) {
          <span class="hljs-keyword">this</span>.body = If(<span class="hljs-keyword">this</span>.guard, <span class="hljs-keyword">this</span>.body);
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span>.body || <span class="hljs-keyword">this</span>.index)) {
          <span class="hljs-keyword">this</span>.addBody(Block(Var(<span class="hljs-keyword">this</span>.index = <span class="hljs-string">'ridx$'</span>)));
        }
        last = (ref$ = <span class="hljs-keyword">this</span>.body.lines) != <span class="hljs-literal">null</span> ? ref$[ref$.length - <span class="hljs-number">1</span>] : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>;
        <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">this</span>.isComprehension || <span class="hljs-keyword">this</span>.inComprehension) &amp;&amp; !(last != <span class="hljs-literal">null</span> &amp;&amp; last.isComprehension)) {
          <span class="hljs-keyword">this</span>.body.makeReturn(it);
          <span class="hljs-keyword">if</span> ((ref1$ = <span class="hljs-keyword">this</span>[<span class="hljs-string">'else'</span>]) != <span class="hljs-literal">null</span>) {
            ref1$.makeReturn(it);
          }
          <span class="hljs-keyword">this</span>.hasReturned = <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">this</span>.resVar = it;
          <span class="hljs-keyword">if</span> ((ref2$ = <span class="hljs-keyword">this</span>[<span class="hljs-string">'else'</span>]) != <span class="hljs-literal">null</span>) {
            ref2$.makeReturn(it);
          }
        }
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.getJump() || (<span class="hljs-keyword">this</span>.returns = <span class="hljs-literal">true</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  prototype.compileNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> test, ref$, head, that;
    o.loop = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">this</span>.test &amp;&amp; (<span class="hljs-keyword">this</span>.un
      ? <span class="hljs-keyword">this</span>.test = <span class="hljs-keyword">this</span>.test.invert()
      : <span class="hljs-keyword">this</span>.anaphorize());
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.post) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">'do {'</span> + <span class="hljs-keyword">this</span>.compileBody((o.indent += TAB, o));
    }
    test = ((ref$ = <span class="hljs-keyword">this</span>.test) != <span class="hljs-literal">null</span> ? ref$.compile(o, LEVEL_PAREN) : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>) || <span class="hljs-string">''</span>;
    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span>.update || <span class="hljs-keyword">this</span>[<span class="hljs-string">'else'</span>])) {
      head = test ? <span class="hljs-string">"while ("</span> + test : <span class="hljs-string">'for (;;'</span>;
    } <span class="hljs-keyword">else</span> {
      head = <span class="hljs-string">'for ('</span>;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[<span class="hljs-string">'else'</span>]) {
        head += (<span class="hljs-keyword">this</span>.yet = o.scope.temporary(<span class="hljs-string">'yet'</span>)) + <span class="hljs-string">" = true"</span>;
      }
      head += <span class="hljs-string">";"</span> + (test &amp;&amp; <span class="hljs-string">' '</span> + test) + <span class="hljs-string">";"</span>;
      <span class="hljs-keyword">if</span> (that = <span class="hljs-keyword">this</span>.update) {
        head += <span class="hljs-string">' '</span> + that.compile(o, LEVEL_PAREN);
      }
    }
    <span class="hljs-keyword">return</span> head + <span class="hljs-string">') {'</span> + <span class="hljs-keyword">this</span>.compileBody((o.indent += TAB, o));
  };
  prototype.compileBody = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> lines, yet, tab, code, ret, mid, empty, resultName, last, hasLoop, res, temp, key$, ref$, that;
    o[<span class="hljs-string">'break'</span>] = o[<span class="hljs-string">'continue'</span>] = <span class="hljs-literal">true</span>;
    lines = <span class="hljs-keyword">this</span>.body.lines, yet = <span class="hljs-keyword">this</span>.yet, tab = <span class="hljs-keyword">this</span>.tab;
    code = ret = mid = <span class="hljs-string">''</span>;
    empty = <span class="hljs-keyword">this</span>.objComp ? <span class="hljs-string">'{}'</span> : <span class="hljs-string">'[]'</span>;
    resultName = <span class="hljs-keyword">this</span>.objComp ? <span class="hljs-string">'resultObj$'</span> : <span class="hljs-string">'results$'</span>;
    last = lines != <span class="hljs-literal">null</span> ? lines[lines.length - <span class="hljs-number">1</span>] : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>;
    <span class="hljs-keyword">if</span> (!((<span class="hljs-keyword">this</span>.isComprehension || <span class="hljs-keyword">this</span>.inComprehension) &amp;&amp; !(last != <span class="hljs-literal">null</span> &amp;&amp; last.isComprehension))) {
      <span class="hljs-keyword">if</span> (last != <span class="hljs-literal">null</span>) {
        last.traverseChildren(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
          <span class="hljs-keyword">var</span> ref$;
          <span class="hljs-keyword">if</span> (it <span class="hljs-keyword">instanceof</span> Block &amp;&amp; (ref$ = it.lines)[ref$.length - <span class="hljs-number">1</span>] <span class="hljs-keyword">instanceof</span> While) {
            hasLoop = <span class="hljs-literal">true</span>;
          }
        });
      }
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.returns &amp;&amp; !<span class="hljs-keyword">this</span>.resVar) {
        <span class="hljs-keyword">this</span>.resVar = res = o.scope.assign(resultName, empty);
      }
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.resVar &amp;&amp; (last <span class="hljs-keyword">instanceof</span> While || hasLoop)) {
        temp = o.scope.temporary(<span class="hljs-string">'lresult'</span>);
        lines.unshift(Assign(Var(temp), lines[lines.length - <span class="hljs-number">1</span>].objComp
          ? Obj()
          : Arr(), <span class="hljs-string">'='</span>));
        <span class="hljs-keyword">if</span> (lines[key$ = lines.length - <span class="hljs-number">1</span>] != <span class="hljs-literal">null</span>) {
          lines[key$] = lines[key$].makeReturn(temp);
        }
        mid += TAB + <span class="hljs-string">""</span> + Chain(Var(<span class="hljs-keyword">this</span>.resVar)).add(Index(Key(<span class="hljs-string">'push'</span>), <span class="hljs-string">'.'</span>, <span class="hljs-literal">true</span>)).add(Call([Chain(Var(temp))])).compile(o) + <span class="hljs-string">";\n"</span> + <span class="hljs-keyword">this</span>.tab;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.hasReturned = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.resVar) {
          <span class="hljs-keyword">this</span>.body.makeReturn(<span class="hljs-keyword">this</span>.resVar);
        }
      }
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.returns) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.objComp) {
        <span class="hljs-keyword">this</span>.body = Block(<span class="hljs-keyword">this</span>.body.makeObjReturn(resultName));
      }
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.guard &amp;&amp; <span class="hljs-keyword">this</span>.objComp) {
        <span class="hljs-keyword">this</span>.body = If(<span class="hljs-keyword">this</span>.guard, <span class="hljs-keyword">this</span>.body);
      }
      <span class="hljs-keyword">if</span> ((!last <span class="hljs-keyword">instanceof</span> While &amp;&amp; !<span class="hljs-keyword">this</span>.hasReturned) || <span class="hljs-keyword">this</span>.isComprehension || <span class="hljs-keyword">this</span>.inComprehension) {
        <span class="hljs-keyword">if</span> (lines[key$ = lines.length - <span class="hljs-number">1</span>] != <span class="hljs-literal">null</span>) {
          lines[key$] = lines[key$].makeReturn(res = o.scope.assign(resultName, empty));
        }
      }
      ret += <span class="hljs-string">"\n"</span> + <span class="hljs-keyword">this</span>.tab + <span class="hljs-string">"return "</span> + (res || empty) + <span class="hljs-string">";"</span>;
      <span class="hljs-keyword">if</span> ((ref$ = <span class="hljs-keyword">this</span>[<span class="hljs-string">'else'</span>]) != <span class="hljs-literal">null</span>) {
        ref$.makeReturn();
      }
    }
    yet &amp;&amp; lines.unshift(JS(yet + <span class="hljs-string">" = false;"</span>));
    <span class="hljs-keyword">if</span> (that = <span class="hljs-keyword">this</span>.body.compile(o, LEVEL_TOP)) {
      code += <span class="hljs-string">"\n"</span> + that + <span class="hljs-string">"\n"</span> + tab;
    }
    code += mid;
    code += <span class="hljs-string">'}'</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.post) {
      code += <span class="hljs-string">" while ("</span> + <span class="hljs-keyword">this</span>.test.compile((o.tab = tab, o), LEVEL_PAREN) + <span class="hljs-string">");"</span>;
    }
    <span class="hljs-keyword">if</span> (yet) {
      code += <span class="hljs-string">" if ("</span> + yet + <span class="hljs-string">") "</span> + <span class="hljs-keyword">this</span>.compileBlock(o, Block(<span class="hljs-keyword">this</span>[<span class="hljs-string">'else'</span>]));
      o.scope.free(yet);
    }
    <span class="hljs-keyword">return</span> code + ret;
  };
  <span class="hljs-keyword">return</span> While;
}(Node));
exports.For = For = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(For, superclass).displayName = <span class="hljs-string">'For'</span>, For), superclass).prototype, constructor = For;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">For</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">var</span> i$, x$, ref$, len$;
    importAll$(<span class="hljs-keyword">this</span>, it);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.item <span class="hljs-keyword">instanceof</span> Var &amp;&amp; !<span class="hljs-keyword">this</span>.item.value) {
      <span class="hljs-keyword">this</span>.item = <span class="hljs-literal">null</span>;
    }
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = <span class="hljs-keyword">this</span>.kind || []).length; i$ &lt; len$; ++i$) {
      x$ = ref$[i$];
      <span class="hljs-keyword">this</span>[x$] = <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.own &amp;&amp; !<span class="hljs-keyword">this</span>.object) {
      <span class="hljs-keyword">this</span>.carp(<span class="hljs-string">'`for own` requires `of`'</span>);
    }
  }
  prototype.children = [<span class="hljs-string">'item'</span>, <span class="hljs-string">'source'</span>, <span class="hljs-string">'from'</span>, <span class="hljs-string">'to'</span>, <span class="hljs-string">'step'</span>, <span class="hljs-string">'body'</span>];
  prototype.aSource = <span class="hljs-literal">null</span>;
  prototype.show = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.kind.concat(<span class="hljs-keyword">this</span>.index)).join(<span class="hljs-string">' '</span>);
  };
  prototype.addBody = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(body)</span>{</span>
    <span class="hljs-keyword">var</span> ref$, x$, that, <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[<span class="hljs-string">'let'</span>]) {
      <span class="hljs-keyword">if</span> (ref$ = <span class="hljs-keyword">this</span>.ref, <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.ref, ref$) {
        <span class="hljs-keyword">this</span>.item = Literal(<span class="hljs-string">'..'</span>);
      }
      body = Block(Call[<span class="hljs-string">'let'</span>]((x$ = [], (that = <span class="hljs-keyword">this</span>.index) &amp;&amp; x$.push(Assign(Var(that), Literal(<span class="hljs-string">'index$$'</span>))), (that = <span class="hljs-keyword">this</span>.item) &amp;&amp; x$.push(Assign(that, Literal(<span class="hljs-string">'item$$'</span>))), x$), body));
    }
    superclass.prototype.addBody.call(<span class="hljs-keyword">this</span>, body);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.guard &amp;&amp; <span class="hljs-keyword">this</span>[<span class="hljs-string">'let'</span>] &amp;&amp; (<span class="hljs-keyword">this</span>.index || <span class="hljs-keyword">this</span>.item)) {
      <span class="hljs-keyword">this</span>.body.lines[<span class="hljs-number">0</span>][<span class="hljs-string">'if'</span>].traverseChildren(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
        <span class="hljs-keyword">if</span> (it <span class="hljs-keyword">instanceof</span> Var) {
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>$.index &amp;&amp; it.value === <span class="hljs-keyword">this</span>$.index) {
            it.value = <span class="hljs-string">'index$$'</span>;
          }
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>$.item &amp;&amp; it.value === <span class="hljs-keyword">this</span>$.item.value) {
            it.value = <span class="hljs-string">'item$$'</span>;
          }
        }
      });
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[<span class="hljs-string">'let'</span>]) {
      <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.index;
      <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.item;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  prototype.compileNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> temps, idx, ref$, pvar, step, tvar, tail, fvar, vars, eq, cond, svar, srcPart, lvar, head, that, body;
    o.loop = <span class="hljs-literal">true</span>;
    temps = <span class="hljs-keyword">this</span>.temps = [];
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.object &amp;&amp; <span class="hljs-keyword">this</span>.index) {
      o.scope.declare(idx = <span class="hljs-keyword">this</span>.index);
    } <span class="hljs-keyword">else</span> {
      temps.push(idx = o.scope.temporary(<span class="hljs-string">'i'</span>));
    }
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.body) {
      <span class="hljs-keyword">this</span>.addBody(Block(Var(idx)));
    }
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.object) {
      ref$ = (<span class="hljs-keyword">this</span>.step || Literal(<span class="hljs-number">1</span>)).compileLoopReference(o, <span class="hljs-string">'step'</span>), pvar = ref$[<span class="hljs-number">0</span>], step = ref$[<span class="hljs-number">1</span>];
      pvar === step || temps.push(pvar);
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.from) {
      ref$ = <span class="hljs-keyword">this</span>.to.compileLoopReference(o, <span class="hljs-string">'to'</span>), tvar = ref$[<span class="hljs-number">0</span>], tail = ref$[<span class="hljs-number">1</span>];
      fvar = <span class="hljs-keyword">this</span>.from.compile(o, LEVEL_LIST);
      vars = idx + <span class="hljs-string">" = "</span> + fvar;
      <span class="hljs-keyword">if</span> (tail !== tvar) {
        vars += <span class="hljs-string">", "</span> + tail;
        temps.push(tvar);
      }
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.step &amp;&amp; +fvar &gt; +tvar) {
        pvar = step = -<span class="hljs-number">1</span>;
      }
      eq = <span class="hljs-keyword">this</span>.op === <span class="hljs-string">'til'</span> ? <span class="hljs-string">''</span> : <span class="hljs-string">'='</span>;
      cond = +pvar
        ? idx + <span class="hljs-string">" "</span> + <span class="hljs-string">'&lt;&gt;'</span>.charAt(pvar &lt; <span class="hljs-number">0</span>) + eq + <span class="hljs-string">" "</span> + tvar
        : pvar + <span class="hljs-string">" &lt; 0 ? "</span> + idx + <span class="hljs-string">" &gt;"</span> + eq + <span class="hljs-string">" "</span> + tvar + <span class="hljs-string">" : "</span> + idx + <span class="hljs-string">" &lt;"</span> + eq + <span class="hljs-string">" "</span> + tvar;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.ref) {
        <span class="hljs-keyword">this</span>.item = Var(o.scope.temporary(<span class="hljs-string">'x'</span>));
      }
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.item || <span class="hljs-keyword">this</span>.object &amp;&amp; <span class="hljs-keyword">this</span>.own || <span class="hljs-keyword">this</span>[<span class="hljs-string">'let'</span>]) {
        ref$ = <span class="hljs-keyword">this</span>.source.compileLoopReference(o, <span class="hljs-string">'ref'</span>, !<span class="hljs-keyword">this</span>.object), svar = ref$[<span class="hljs-number">0</span>], srcPart = ref$[<span class="hljs-number">1</span>];
        svar === srcPart || temps.push(svar);
      } <span class="hljs-keyword">else</span> {
        svar = srcPart = <span class="hljs-keyword">this</span>.source.compile(o, LEVEL_PAREN);
      }
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.object) {
        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &gt; pvar &amp;&amp; ~~pvar === +pvar) {
          vars = idx + <span class="hljs-string">" = "</span> + srcPart + <span class="hljs-string">".length - 1"</span>;
          cond = idx + <span class="hljs-string">" &gt;= 0"</span>;
        } <span class="hljs-keyword">else</span> {
          temps.push(lvar = o.scope.temporary(<span class="hljs-string">'len'</span>));
          vars = idx + <span class="hljs-string">" = 0, "</span> + lvar + <span class="hljs-string">" = "</span> + srcPart + <span class="hljs-string">".length"</span>;
          cond = idx + <span class="hljs-string">" &lt; "</span> + lvar;
        }
      }
    }
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'else'</span>] &amp;&amp; (<span class="hljs-keyword">this</span>.yet = o.scope.temporary(<span class="hljs-string">'yet'</span>));
    head = <span class="hljs-string">'for ('</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.object) {
      head += idx + <span class="hljs-string">" in "</span>;
    }
    <span class="hljs-keyword">if</span> (that = <span class="hljs-keyword">this</span>.yet) {
      head += that + <span class="hljs-string">" = true, "</span>;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.object) {
      head += srcPart;
    } <span class="hljs-keyword">else</span> {
      step === pvar || (vars += <span class="hljs-string">', '</span> + step);
      head += (vars + <span class="hljs-string">"; "</span> + cond + <span class="hljs-string">"; "</span>) + (<span class="hljs-number">1</span> == <span class="hljs-built_in">Math</span>.abs(pvar)
        ? (pvar &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">'--'</span> : <span class="hljs-string">'++'</span>) + idx
        : idx + (pvar &lt; <span class="hljs-number">0</span>
          ? <span class="hljs-string">' -= '</span> + pvar.slice(<span class="hljs-number">1</span>)
          : <span class="hljs-string">' += '</span> + pvar));
    }
    <span class="hljs-keyword">this</span>.own &amp;&amp; (head += <span class="hljs-string">") if ("</span> + o.scope.assign(<span class="hljs-string">'own$'</span>, <span class="hljs-string">'{}.hasOwnProperty'</span>) + <span class="hljs-string">".call("</span> + svar + <span class="hljs-string">", "</span> + idx + <span class="hljs-string">")"</span>);
    head += <span class="hljs-string">') {'</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[<span class="hljs-string">'let'</span>]) {
      <span class="hljs-keyword">this</span>.body.traverseChildren(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
        <span class="hljs-keyword">switch</span> (it.value) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'index$$'</span>:
          it.value = idx;
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'item$$'</span>:
          it.value = svar + <span class="hljs-string">"["</span> + idx + <span class="hljs-string">"]"</span>;
        }
      });
    }
    o.indent += TAB;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.index &amp;&amp; !<span class="hljs-keyword">this</span>.object) {
      head += <span class="hljs-string">'\n'</span> + o.indent + Assign(Var(<span class="hljs-keyword">this</span>.index), JS(idx)).compile(o, LEVEL_TOP) + <span class="hljs-string">';'</span>;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.item &amp;&amp; !<span class="hljs-keyword">this</span>.item.isEmpty()) {
      head += <span class="hljs-string">'\n'</span> + o.indent + Assign(<span class="hljs-keyword">this</span>.item, JS(svar + <span class="hljs-string">"["</span> + idx + <span class="hljs-string">"]"</span>)).compile(o, LEVEL_TOP) + <span class="hljs-string">';'</span>;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.ref) {
      o.ref = <span class="hljs-keyword">this</span>.item.value;
    }
    body = <span class="hljs-keyword">this</span>.compileBody(o);
    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">this</span>.item || (<span class="hljs-keyword">this</span>.index &amp;&amp; !<span class="hljs-keyword">this</span>.object)) &amp;&amp; <span class="hljs-string">'}'</span> === body.charAt(<span class="hljs-number">0</span>)) {
      head += <span class="hljs-string">'\n'</span> + <span class="hljs-keyword">this</span>.tab;
    }
    <span class="hljs-keyword">return</span> head + body;
  };
  <span class="hljs-keyword">return</span> For;
}(While));
exports.Try = Try = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Try, superclass).displayName = <span class="hljs-string">'Try'</span>, Try), superclass).prototype, constructor = Try;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Try</span><span class="hljs-params">(attempt, thrown, recovery, ensure)</span>{</span>
    <span class="hljs-keyword">var</span> ref$;
    <span class="hljs-keyword">this</span>.attempt = attempt;
    <span class="hljs-keyword">this</span>.thrown = thrown;
    <span class="hljs-keyword">this</span>.recovery = recovery;
    <span class="hljs-keyword">this</span>.ensure = ensure;
    <span class="hljs-keyword">if</span> ((ref$ = <span class="hljs-keyword">this</span>.recovery) != <span class="hljs-literal">null</span>) {
      ref$.lines.unshift(Assign(<span class="hljs-keyword">this</span>.thrown || Var(<span class="hljs-string">'e'</span>), Var(<span class="hljs-string">'e$'</span>)));
    }
  }
  prototype.children = [<span class="hljs-string">'attempt'</span>, <span class="hljs-string">'recovery'</span>, <span class="hljs-string">'ensure'</span>];
  prototype.show = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.thrown;
  };
  prototype.isStatement = YES;
  prototype.isCallable = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> ref$;
    <span class="hljs-keyword">return</span> ((ref$ = <span class="hljs-keyword">this</span>.recovery) != <span class="hljs-literal">null</span> ? ref$.isCallable() : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>) &amp;&amp; <span class="hljs-keyword">this</span>.attempt.isCallable();
  };
  prototype.getJump = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">var</span> ref$;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.attempt.getJump(it) || ((ref$ = <span class="hljs-keyword">this</span>.recovery) != <span class="hljs-literal">null</span> ? ref$.getJump(it) : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>);
  };
  prototype.makeReturn = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">this</span>.attempt = <span class="hljs-keyword">this</span>.attempt.makeReturn(it);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.recovery != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">this</span>.recovery = <span class="hljs-keyword">this</span>.recovery.makeReturn(it);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  prototype.compileNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> code, that;
    o.indent += TAB;
    code = <span class="hljs-string">'try '</span> + <span class="hljs-keyword">this</span>.compileBlock(o, <span class="hljs-keyword">this</span>.attempt);
    <span class="hljs-keyword">if</span> (that = <span class="hljs-keyword">this</span>.recovery || !<span class="hljs-keyword">this</span>.ensure &amp;&amp; JS(<span class="hljs-string">''</span>)) {
      code += <span class="hljs-string">' catch (e$) '</span> + <span class="hljs-keyword">this</span>.compileBlock(o, that);
    }
    <span class="hljs-keyword">if</span> (that = <span class="hljs-keyword">this</span>.ensure) {
      code += <span class="hljs-string">' finally '</span> + <span class="hljs-keyword">this</span>.compileBlock(o, that);
    }
    <span class="hljs-keyword">return</span> code;
  };
  <span class="hljs-keyword">return</span> Try;
}(Node));
exports.Switch = Switch = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Switch, superclass).displayName = <span class="hljs-string">'Switch'</span>, Switch), superclass).prototype, constructor = Switch;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Switch</span><span class="hljs-params">(type, topic, cases, $default)</span>{</span>
    <span class="hljs-keyword">var</span> last, ref$;
    <span class="hljs-keyword">this</span>.type = type;
    <span class="hljs-keyword">this</span>.topic = topic;
    <span class="hljs-keyword">this</span>.cases = cases;
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'default'</span>] = $<span class="hljs-keyword">default</span>;
    <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'match'</span>) {
      <span class="hljs-keyword">if</span> (topic) {
        <span class="hljs-keyword">this</span>.target = Arr(topic);
      }
      <span class="hljs-keyword">this</span>.topic = <span class="hljs-literal">null</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (topic) {
        <span class="hljs-keyword">if</span> (topic.length &gt; <span class="hljs-number">1</span>) {
          <span class="hljs-keyword">throw</span> <span class="hljs-string">"can't have more than one topic in switch statement"</span>;
        }
        <span class="hljs-keyword">this</span>.topic = <span class="hljs-keyword">this</span>.topic[<span class="hljs-number">0</span>];
      }
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cases.length &amp;&amp; (last = (ref$ = <span class="hljs-keyword">this</span>.cases)[ref$.length - <span class="hljs-number">1</span>]).tests.length === <span class="hljs-number">1</span> &amp;&amp; last.tests[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> Var &amp;&amp; last.tests[<span class="hljs-number">0</span>].value === <span class="hljs-string">'_'</span>) {
      <span class="hljs-keyword">this</span>.cases.pop();
      <span class="hljs-keyword">this</span>[<span class="hljs-string">'default'</span>] = last.body;
    }
  }
  prototype.children = [<span class="hljs-string">'topic'</span>, <span class="hljs-string">'cases'</span>, <span class="hljs-string">'default'</span>];
  prototype.aSource = <span class="hljs-string">'topic'</span>;
  prototype.aTargets = [<span class="hljs-string">'cases'</span>, <span class="hljs-string">'default'</span>];
  prototype.show = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.type;
  };
  prototype.isStatement = YES;
  prototype.isCallable = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> i$, ref$, len$, c;
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = <span class="hljs-keyword">this</span>.cases).length; i$ &lt; len$; ++i$) {
      c = ref$[i$];
      <span class="hljs-keyword">if</span> (!c.isCallable()) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[<span class="hljs-string">'default'</span>]) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[<span class="hljs-string">'default'</span>].isCallable();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  };
  prototype.getJump = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ctx)</span>{</span>
    <span class="hljs-keyword">var</span> i$, ref$, len$, c, that;
    ctx || (ctx = {});
    ctx[<span class="hljs-string">'break'</span>] = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = <span class="hljs-keyword">this</span>.cases).length; i$ &lt; len$; ++i$) {
      c = ref$[i$];
      <span class="hljs-keyword">if</span> (that = c.body.getJump(ctx)) {
        <span class="hljs-keyword">return</span> that;
      }
    }
    <span class="hljs-keyword">return</span> (ref$ = <span class="hljs-keyword">this</span>[<span class="hljs-string">'default'</span>]) != <span class="hljs-literal">null</span> ? ref$.getJump(ctx) : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>;
  };
  prototype.makeReturn = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">var</span> i$, ref$, len$, c;
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = <span class="hljs-keyword">this</span>.cases).length; i$ &lt; len$; ++i$) {
      c = ref$[i$];
      c.makeReturn(it);
    }
    <span class="hljs-keyword">if</span> ((ref$ = <span class="hljs-keyword">this</span>[<span class="hljs-string">'default'</span>]) != <span class="hljs-literal">null</span>) {
      ref$.makeReturn(it);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  prototype.compileNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> tab, ref$, targetNode, target, topic, t, code, stop, i$, len$, i, c, that;
    tab = <span class="hljs-keyword">this</span>.tab;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.target) {
      ref$ = Chain(<span class="hljs-keyword">this</span>.target).cacheReference(o), targetNode = ref$[<span class="hljs-number">0</span>], target = ref$[<span class="hljs-number">1</span>];
    }
    topic = <span class="hljs-keyword">this</span>.type === <span class="hljs-string">'match'</span>
      ? (t = target
        ? [targetNode]
        : [], Block(t.concat([Literal(<span class="hljs-string">'false'</span>)])).compile(o, LEVEL_PAREN))
      : !!<span class="hljs-keyword">this</span>.topic &amp;&amp; <span class="hljs-keyword">this</span>.anaphorize().compile(o, LEVEL_PAREN);
    code = <span class="hljs-string">"switch ("</span> + topic + <span class="hljs-string">") {\n"</span>;
    stop = <span class="hljs-keyword">this</span>[<span class="hljs-string">'default'</span>] || <span class="hljs-keyword">this</span>.cases.length - <span class="hljs-number">1</span>;
    o[<span class="hljs-string">'break'</span>] = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = <span class="hljs-keyword">this</span>.cases).length; i$ &lt; len$; ++i$) {
      i = i$;
      c = ref$[i$];
      code += c.compileCase(o, tab, i === stop, <span class="hljs-keyword">this</span>.type === <span class="hljs-string">'match'</span> || !topic, <span class="hljs-keyword">this</span>.type, target);
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[<span class="hljs-string">'default'</span>]) {
      o.indent = tab + TAB;
      <span class="hljs-keyword">if</span> (that = <span class="hljs-keyword">this</span>[<span class="hljs-string">'default'</span>].compile(o, LEVEL_TOP)) {
        code += tab + (<span class="hljs-string">"default:\n"</span> + that + <span class="hljs-string">"\n"</span>);
      }
    }
    <span class="hljs-keyword">return</span> code + tab + <span class="hljs-string">'}'</span>;
  };
  <span class="hljs-keyword">return</span> Switch;
}(Node));
exports.Case = Case = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Case, superclass).displayName = <span class="hljs-string">'Case'</span>, Case), superclass).prototype, constructor = Case;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Case</span><span class="hljs-params">(tests, body)</span>{</span>
    <span class="hljs-keyword">this</span>.tests = tests;
    <span class="hljs-keyword">this</span>.body = body;
  }
  prototype.children = [<span class="hljs-string">'tests'</span>, <span class="hljs-string">'body'</span>];
  prototype.isCallable = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.body.isCallable();
  };
  prototype.makeReturn = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">var</span> ref$, ref1$;
    <span class="hljs-keyword">if</span> (((ref$ = (ref1$ = <span class="hljs-keyword">this</span>.body.lines)[ref1$.length - <span class="hljs-number">1</span>]) != <span class="hljs-literal">null</span> ? ref$.value : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>) !== <span class="hljs-string">'fallthrough'</span>) {
      <span class="hljs-keyword">this</span>.body.makeReturn(it);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  prototype.compileCase = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, tab, nobr, bool, type, target)</span>{</span>
    <span class="hljs-keyword">var</span> tests, i$, ref$, len$, test, j$, ref1$, len1$, t, i, tar, binary, that, code, lines, last, ft;
    tests = [];
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = <span class="hljs-keyword">this</span>.tests).length; i$ &lt; len$; ++i$) {
      test = ref$[i$];
      test = test.expandSlice(o).unwrap();
      <span class="hljs-keyword">if</span> (test <span class="hljs-keyword">instanceof</span> Arr &amp;&amp; type !== <span class="hljs-string">'match'</span>) {
        <span class="hljs-keyword">for</span> (j$ = <span class="hljs-number">0</span>, len1$ = (ref1$ = test.items).length; j$ &lt; len1$; ++j$) {
          t = ref1$[j$];
          tests.push(t);
        }
      } <span class="hljs-keyword">else</span> {
        tests.push(test);
      }
    }
    tests.length || tests.push(Literal(<span class="hljs-string">'void'</span>));
    <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'match'</span>) {
      <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = tests.length; i$ &lt; len$; ++i$) {
        i = i$;
        test = tests[i$];
        tar = Chain(target).add(Index(Literal(i), <span class="hljs-string">'.'</span>, <span class="hljs-literal">true</span>));
        tests[i] = Chain(test).autoCompare(target ? [tar] : <span class="hljs-literal">null</span>);
      }
    }
    <span class="hljs-keyword">if</span> (bool) {
      binary = type === <span class="hljs-string">'match'</span> ? <span class="hljs-string">'&amp;&amp;'</span> : <span class="hljs-string">'||'</span>;
      t = tests[<span class="hljs-number">0</span>];
      i = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">while</span> (that = tests[++i]) {
        t = Binary(binary, t, that);
      }
      tests = [(<span class="hljs-keyword">this</span>.t = t, <span class="hljs-keyword">this</span>.aSource = <span class="hljs-string">'t'</span>, <span class="hljs-keyword">this</span>.aTargets = [<span class="hljs-string">'body'</span>], <span class="hljs-keyword">this</span>).anaphorize().invert()];
    }
    code = <span class="hljs-string">''</span>;
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = tests.length; i$ &lt; len$; ++i$) {
      t = tests[i$];
      code += tab + (<span class="hljs-string">"case "</span> + t.compile(o, LEVEL_PAREN) + <span class="hljs-string">":\n"</span>);
    }
    lines = <span class="hljs-keyword">this</span>.body.lines;
    last = lines[lines.length - <span class="hljs-number">1</span>];
    <span class="hljs-keyword">if</span> (ft = (last != <span class="hljs-literal">null</span> ? last.value : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>) === <span class="hljs-string">'fallthrough'</span>) {
      lines[lines.length - <span class="hljs-number">1</span>] = JS(<span class="hljs-string">'// fallthrough'</span>);
    }
    o.indent = tab += TAB;
    <span class="hljs-keyword">if</span> (that = <span class="hljs-keyword">this</span>.body.compile(o, LEVEL_TOP)) {
      code += that + <span class="hljs-string">'\n'</span>;
    }
    <span class="hljs-keyword">if</span> (!(nobr || ft || last <span class="hljs-keyword">instanceof</span> Jump)) {
      code += tab + <span class="hljs-string">'break;\n'</span>;
    }
    <span class="hljs-keyword">return</span> code;
  };
  <span class="hljs-keyword">return</span> Case;
}(Node));
exports.If = If = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(If, superclass).displayName = <span class="hljs-string">'If'</span>, If), superclass).prototype, constructor = If;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">If</span><span class="hljs-params">($if, then, un)</span>{</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">this</span>$[<span class="hljs-string">'if'</span>] = $<span class="hljs-keyword">if</span>;
    <span class="hljs-keyword">this</span>$.then = then;
    <span class="hljs-keyword">this</span>$.un = un;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.children = [<span class="hljs-string">'if'</span>, <span class="hljs-string">'then'</span>, <span class="hljs-string">'else'</span>];
  prototype.aSource = <span class="hljs-string">'if'</span>;
  prototype.aTargets = [<span class="hljs-string">'then'</span>];
  prototype.show = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.un &amp;&amp; <span class="hljs-string">'!'</span>;
  };
  prototype.terminator = <span class="hljs-string">''</span>;
  prototype.delegate([<span class="hljs-string">'isCallable'</span>, <span class="hljs-string">'isArray'</span>, <span class="hljs-string">'isString'</span>, <span class="hljs-string">'isRegex'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">var</span> ref$;
    <span class="hljs-keyword">return</span> ((ref$ = <span class="hljs-keyword">this</span>[<span class="hljs-string">'else'</span>]) != <span class="hljs-literal">null</span> ? ref$[it]() : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>) &amp;&amp; <span class="hljs-keyword">this</span>.then[it]();
  });
  prototype.getJump = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">var</span> ref$;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then.getJump(it) || ((ref$ = <span class="hljs-keyword">this</span>[<span class="hljs-string">'else'</span>]) != <span class="hljs-literal">null</span> ? ref$.getJump(it) : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>);
  };
  prototype.makeReturn = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">this</span>.then = <span class="hljs-keyword">this</span>.then.makeReturn(it);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[<span class="hljs-string">'else'</span>] != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">this</span>[<span class="hljs-string">'else'</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'else'</span>].makeReturn(it);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  prototype.compileNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.un) {
      <span class="hljs-keyword">this</span>[<span class="hljs-string">'if'</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'if'</span>].invert();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.soak || <span class="hljs-keyword">this</span>.anaphorize();
    }
    <span class="hljs-keyword">if</span> (o.level) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileExpression(o);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compileStatement(o);
    }
  };
  prototype.compileStatement = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> code, els;
    code = <span class="hljs-string">"if ("</span> + <span class="hljs-keyword">this</span>[<span class="hljs-string">'if'</span>].compile(o, LEVEL_PAREN) + <span class="hljs-string">") "</span>;
    o.indent += TAB;
    code += <span class="hljs-keyword">this</span>.compileBlock(o, Block(<span class="hljs-keyword">this</span>.then));
    <span class="hljs-keyword">if</span> (!(els = <span class="hljs-keyword">this</span>[<span class="hljs-string">'else'</span>])) {
      <span class="hljs-keyword">return</span> code;
    }
    <span class="hljs-keyword">return</span> code + <span class="hljs-string">' else '</span> + (els <span class="hljs-keyword">instanceof</span> constructor
      ? els.compile((o.indent = <span class="hljs-keyword">this</span>.tab, o), LEVEL_TOP)
      : <span class="hljs-keyword">this</span>.compileBlock(o, els));
  };
  prototype.compileExpression = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> thn, els, code, pad;
    thn = <span class="hljs-keyword">this</span>.then, els = <span class="hljs-keyword">this</span>[<span class="hljs-string">'else'</span>] || Literal(<span class="hljs-string">'void'</span>);
    <span class="hljs-keyword">this</span>[<span class="hljs-string">'void'</span>] &amp;&amp; (thn[<span class="hljs-string">'void'</span>] = els[<span class="hljs-string">'void'</span>] = <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>[<span class="hljs-string">'else'</span>] &amp;&amp; (<span class="hljs-keyword">this</span>.cond || <span class="hljs-keyword">this</span>[<span class="hljs-string">'void'</span>])) {
      <span class="hljs-keyword">return</span> Parens(Binary(<span class="hljs-string">'&amp;&amp;'</span>, <span class="hljs-keyword">this</span>[<span class="hljs-string">'if'</span>], thn)).compile(o);
    }
    code = <span class="hljs-keyword">this</span>[<span class="hljs-string">'if'</span>].compile(o, LEVEL_COND);
    pad = els.isComplex() ? <span class="hljs-string">'\n'</span> + (o.indent += TAB) : <span class="hljs-string">' '</span>;
    code += pad + <span class="hljs-string">"? "</span> + thn.compile(o, LEVEL_LIST) + <span class="hljs-string">""</span> + pad + <span class="hljs-string">": "</span> + els.compile(o, LEVEL_LIST);
    <span class="hljs-keyword">if</span> (o.level &lt; LEVEL_COND) {
      <span class="hljs-keyword">return</span> code;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"("</span> + code + <span class="hljs-string">")"</span>;
    }
  };
  If.unfoldSoak = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, parent, name)</span>{</span>
    <span class="hljs-keyword">var</span> that;
    <span class="hljs-keyword">if</span> (that = parent[name].unfoldSoak(o)) {
      parent[name] = that.then;
      <span class="hljs-keyword">return</span> that.cond = parent.cond, that[<span class="hljs-string">'void'</span>] = parent[<span class="hljs-string">'void'</span>], that.then = Chain(parent), that;
    }
  };
  <span class="hljs-keyword">return</span> If;
}(Node));
exports.Label = Label = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> ref$, prototype = extend$((import$(Label, superclass).displayName = <span class="hljs-string">'Label'</span>, Label), superclass).prototype, constructor = Label;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Label</span><span class="hljs-params">(label, it)</span>{</span>
    <span class="hljs-keyword">var</span> fun;
    <span class="hljs-keyword">this</span>.label = label || <span class="hljs-string">'_'</span>;
    <span class="hljs-keyword">this</span>.it = it;
    <span class="hljs-keyword">if</span> (fun = (it <span class="hljs-keyword">instanceof</span> Fun || it <span class="hljs-keyword">instanceof</span> Class) &amp;&amp; it || it.calling &amp;&amp; it.it.head) {
      fun.name || (fun.name = <span class="hljs-keyword">this</span>.label, fun.labeled = <span class="hljs-literal">true</span>);
      <span class="hljs-keyword">return</span> it;
    }
  }
  ref$ = Parens.prototype, prototype.children = ref$.children, prototype.isCallable = ref$.isCallable, prototype.isArray = ref$.isArray;
  prototype.show = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.label;
  };
  prototype.isStatement = YES;
  prototype.getJump = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ctx)</span>{</span>
    <span class="hljs-keyword">var</span> ref$;
    ctx || (ctx = {});
    ((ref$ = ctx.labels) != <span class="hljs-literal">null</span>
      ? ref$
      : ctx.labels = []).push(<span class="hljs-keyword">this</span>.label);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.it.getJump((ctx[<span class="hljs-string">'break'</span>] = <span class="hljs-literal">true</span>, ctx));
  };
  prototype.makeReturn = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">this</span>.it = <span class="hljs-keyword">this</span>.it.makeReturn(it);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  prototype.compileNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> label, it, labels;
    label = <span class="hljs-keyword">this</span>.label, it = <span class="hljs-keyword">this</span>.it;
    labels = o.labels = slice$.call(o.labels || []);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">in</span>$(label, labels)) {
      <span class="hljs-keyword">this</span>.carp(<span class="hljs-string">"duplicate label \""</span> + label + <span class="hljs-string">"\""</span>);
    }
    labels.push(label);
    it.isStatement() || (it = Block(it));
    <span class="hljs-keyword">return</span> (label + <span class="hljs-string">": "</span>) + (it <span class="hljs-keyword">instanceof</span> Block
      ? (o.indent += TAB, <span class="hljs-keyword">this</span>.compileBlock(o, it))
      : it.compile(o));
  };
  <span class="hljs-keyword">return</span> Label;
}(Node));
exports.Cascade = Cascade = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Cascade, superclass).displayName = <span class="hljs-string">'Cascade'</span>, Cascade), superclass).prototype, constructor = Cascade;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cascade</span><span class="hljs-params">(input, output, prog1)</span>{</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">this</span>$.input = input;
    <span class="hljs-keyword">this</span>$.output = output;
    <span class="hljs-keyword">this</span>$.prog1 = prog1;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.show = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.prog1;
  };
  prototype.children = [<span class="hljs-string">'input'</span>, <span class="hljs-string">'output'</span>];
  prototype.terminator = <span class="hljs-string">''</span>;
  prototype.delegate([<span class="hljs-string">'isCallable'</span>, <span class="hljs-string">'isArray'</span>, <span class="hljs-string">'isString'</span>, <span class="hljs-string">'isRegex'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[<span class="hljs-keyword">this</span>.prog1 ? <span class="hljs-string">'input'</span> : <span class="hljs-string">'output'</span>][it]();
  });
  prototype.getJump = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.output.getJump(it);
  };
  prototype.makeReturn = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ret)</span>{</span>
    <span class="hljs-keyword">this</span>.ret = ret;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };
  prototype.compileNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> level, input, output, prog1, ref, ref$, code, out;
    level = o.level;
    input = <span class="hljs-keyword">this</span>.input, output = <span class="hljs-keyword">this</span>.output, prog1 = <span class="hljs-keyword">this</span>.prog1, ref = <span class="hljs-keyword">this</span>.ref;
    <span class="hljs-keyword">if</span> (prog1 &amp;&amp; (<span class="hljs-string">'ret'</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span> || level &amp;&amp; !<span class="hljs-keyword">this</span>[<span class="hljs-string">'void'</span>])) {
      output.add((ref$ = Literal(<span class="hljs-string">'..'</span>), ref$.cascadee = <span class="hljs-literal">true</span>, ref$));
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-string">'ret'</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>) {
      output = output.makeReturn(<span class="hljs-keyword">this</span>.ret);
    }
    <span class="hljs-keyword">if</span> (ref) {
      prog1 || (output = Assign(Var(ref), output));
    } <span class="hljs-keyword">else</span> {
      ref = o.scope.temporary(<span class="hljs-string">'x'</span>);
    }
    <span class="hljs-keyword">if</span> (input <span class="hljs-keyword">instanceof</span> Cascade) {
      input.ref = ref;
    } <span class="hljs-keyword">else</span> {
      input &amp;&amp; (input = Assign(Var(ref), input));
    }
    o.level &amp;&amp; (o.level = LEVEL_PAREN);
    code = input.compile(o);
    out = Block(output).compile((o.ref = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(ref), o));
    <span class="hljs-keyword">if</span> (prog1 === <span class="hljs-string">'cascade'</span> &amp;&amp; !o.ref.erred) {
      <span class="hljs-keyword">this</span>.carp(<span class="hljs-string">"unreferred cascadee"</span>);
    }
    <span class="hljs-keyword">if</span> (!level) {
      <span class="hljs-keyword">return</span> code + <span class="hljs-string">""</span> + input.terminator + <span class="hljs-string">"\n"</span> + out;
    }
    code += <span class="hljs-string">", "</span> + out;
    <span class="hljs-keyword">if</span> (level &gt; LEVEL_PAREN) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"("</span> + code + <span class="hljs-string">")"</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> code;
    }
  };
  <span class="hljs-keyword">return</span> Cascade;
}(Node));
exports.JS = JS = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(JS, superclass).displayName = <span class="hljs-string">'JS'</span>, JS), superclass).prototype, constructor = JS;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">JS</span><span class="hljs-params">(code, literal, comment)</span>{</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">this</span>$.code = code;
    <span class="hljs-keyword">this</span>$.literal = literal;
    <span class="hljs-keyword">this</span>$.comment = comment;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.show = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.comment) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.code;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"`"</span> + <span class="hljs-keyword">this</span>.code + <span class="hljs-string">"`"</span>;
    }
  };
  prototype.terminator = <span class="hljs-string">''</span>;
  prototype.isAssignable = prototype.isCallable = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.comment;
  };
  prototype.compile = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.literal) {
      <span class="hljs-keyword">return</span> entab(<span class="hljs-keyword">this</span>.code, it.indent);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.code;
    }
  };
  <span class="hljs-keyword">return</span> JS;
}(Node));
exports.Require = Require = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Require, superclass).displayName = <span class="hljs-string">'Require'</span>, Require), superclass).prototype, constructor = Require;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Require</span><span class="hljs-params">(body)</span>{</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">this</span>$.body = body;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.children = [<span class="hljs-string">'body'</span>];
  prototype.compile = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o)</span>{</span>
    <span class="hljs-keyword">var</span> stripString, getFileName, getValue, processItem, item, <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span>;
    stripString = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(val)</span>{</span>
      <span class="hljs-keyword">var</span> that;
      <span class="hljs-keyword">if</span> (that = <span class="hljs-regexp">/^['"](.*)['"]$/</span>.exec(val)) {
        <span class="hljs-keyword">return</span> that[<span class="hljs-number">1</span>];
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> val;
      }
    };
    getFileName = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(val)</span>{</span>
      <span class="hljs-keyword">return</span> path.basename(stripString(val)).split(<span class="hljs-string">'.'</span>)[<span class="hljs-number">0</span>].replace(<span class="hljs-regexp">/-[a-z]/ig</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
        <span class="hljs-keyword">return</span> it.charAt(<span class="hljs-number">1</span>).toUpperCase();
      });
    };
    getValue = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span>{</span>
      <span class="hljs-keyword">switch</span> (<span class="hljs-literal">false</span>) {
      <span class="hljs-keyword">case</span> !(item <span class="hljs-keyword">instanceof</span> Key):
        <span class="hljs-keyword">return</span> item.name;
      <span class="hljs-keyword">case</span> !(item <span class="hljs-keyword">instanceof</span> Var):
        <span class="hljs-keyword">return</span> item.value;
      <span class="hljs-keyword">case</span> !(item <span class="hljs-keyword">instanceof</span> Literal):
        <span class="hljs-keyword">return</span> item.value;
      <span class="hljs-keyword">case</span> !(item <span class="hljs-keyword">instanceof</span> Index):
        <span class="hljs-keyword">return</span> getValue(item.key);
      <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">return</span> item;
      }
    };
    processItem = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span>{</span>
      <span class="hljs-keyword">var</span> ref$, asg, value, asgValue, toAsg, main;
      ref$ = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
        <span class="hljs-keyword">switch</span> (<span class="hljs-literal">false</span>) {
        <span class="hljs-keyword">case</span> !(item <span class="hljs-keyword">instanceof</span> Prop):
          <span class="hljs-keyword">return</span> [item.val, item.key];
        <span class="hljs-keyword">default</span>:
          <span class="hljs-keyword">return</span> [item, item];
        }
      }()), asg = ref$[<span class="hljs-number">0</span>], value = ref$[<span class="hljs-number">1</span>];
      asgValue = getValue(asg);
      toAsg = toString$.call(asgValue).slice(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>) === <span class="hljs-string">'String'</span> ? Var(getFileName(asgValue)) : asg;
      value = stripString(getValue(value));
      main = Chain(Var(<span class="hljs-string">'require'</span>)).add(Call([Literal(<span class="hljs-string">"'"</span> + value + <span class="hljs-string">"'"</span>)]));
      <span class="hljs-keyword">return</span> Assign(toAsg, main).compile(o);
    };
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.body.items != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
        <span class="hljs-keyword">var</span> i$, ref$, len$, results$ = [];
        <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = <span class="hljs-keyword">this</span>.body.items).length; i$ &lt; len$; ++i$) {
          item = ref$[i$];
          results$.push(processItem(item));
        }
        <span class="hljs-keyword">return</span> results$;
      }.call(<span class="hljs-keyword">this</span>)).join(<span class="hljs-string">";\n"</span> + o.indent);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> processItem(<span class="hljs-keyword">this</span>.body);
    }
  };
  <span class="hljs-keyword">return</span> Require;
}(Node));
exports.Util = Util = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Util, superclass).displayName = <span class="hljs-string">'Util'</span>, Util), superclass).prototype, constructor = Util;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Util</span><span class="hljs-params">(verb)</span>{</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">this</span>$.verb = verb;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.show = Jump.prototype.show;
  prototype.isCallable = YES;
  prototype.compile = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> util(<span class="hljs-keyword">this</span>.verb);
  };
  Util.Extends = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">return</span> Call.make(Util(<span class="hljs-string">'extend'</span>), [<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>], <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]]);
  };
  <span class="hljs-keyword">return</span> Util;
}(Node));
exports.Vars = Vars = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(superclass)</span>{</span>
  <span class="hljs-keyword">var</span> prototype = extend$((import$(Vars, superclass).displayName = <span class="hljs-string">'Vars'</span>, Vars), superclass).prototype, constructor = Vars;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Vars</span><span class="hljs-params">(vars)</span>{</span>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span>$ = <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> ctor$ ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> ctor$;
    <span class="hljs-keyword">this</span>$.vars = vars;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>$;
  } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor$</span><span class="hljs-params">()</span>{</span>} ctor$.prototype = prototype;
  prototype.children = [<span class="hljs-string">'vars'</span>];
  prototype.makeReturn = THIS;
  prototype.compile = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, level)</span>{</span>
    <span class="hljs-keyword">var</span> i$, ref$, len$, v, value;
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = (ref$ = <span class="hljs-keyword">this</span>.vars).length; i$ &lt; len$; ++i$) {
      v = ref$[i$], value = v.value;
      <span class="hljs-keyword">if</span> (!(v <span class="hljs-keyword">instanceof</span> Var)) {
        v.carp(<span class="hljs-string">'invalid variable declaration'</span>);
      }
      <span class="hljs-keyword">if</span> (o.scope.check(value)) {
        v.carp(<span class="hljs-string">"redeclaration of \""</span> + value + <span class="hljs-string">"\""</span>);
      }
      o.scope.declare(value, v);
    }
    <span class="hljs-keyword">return</span> Literal(<span class="hljs-string">'void'</span>).compile(o, level);
  };
  <span class="hljs-keyword">return</span> Vars;
}(Node));
exports.L = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(yylineno, node)</span>{</span>
  <span class="hljs-keyword">return</span> node.line = yylineno + <span class="hljs-number">1</span>, node;
};
exports.Decl = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(type, nodes, lno)</span>{</span>
  <span class="hljs-keyword">if</span> (!nodes[<span class="hljs-number">0</span>]) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">SyntaxError</span>(<span class="hljs-string">"empty "</span> + type + <span class="hljs-string">" on line "</span> + lno);
  }
  <span class="hljs-keyword">return</span> DECLS[type](nodes);
};
DECLS = {
  <span class="hljs-string">'export'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(lines)</span>{</span>
    <span class="hljs-keyword">var</span> i, out, node, that, ref$;
    i = -<span class="hljs-number">1</span>;
    out = Util(<span class="hljs-string">'out'</span>);
    <span class="hljs-keyword">while</span> (node = lines[++i]) {
      <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Block) {
        lines.splice.apply(lines, [i--, <span class="hljs-number">1</span>].concat(slice$.call(node.lines)));
        <span class="hljs-keyword">continue</span>;
      }
      <span class="hljs-keyword">if</span> (that = node <span class="hljs-keyword">instanceof</span> Fun &amp;&amp; node.name) {
        lines.splice(i++, <span class="hljs-number">0</span>, Assign(Chain(out, [Index(Key(that))]), Var(that)));
        <span class="hljs-keyword">continue</span>;
      }
      lines[i] = (that = node.varName() || node <span class="hljs-keyword">instanceof</span> Assign &amp;&amp; node.left.varName() || node <span class="hljs-keyword">instanceof</span> Class &amp;&amp; ((ref$ = node.title) != <span class="hljs-literal">null</span> ? ref$.varName() : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>))
        ? Assign(Chain(out, [Index(Key(that))]), node)
        : Import(out, node);
    }
    <span class="hljs-keyword">return</span> Block(lines);
  },
  <span class="hljs-string">'import'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(lines, all)</span>{</span>
    <span class="hljs-keyword">var</span> i$, len$, i, line;
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = lines.length; i$ &lt; len$; ++i$) {
      i = i$;
      line = lines[i$];
      lines[i] = Import(Literal(<span class="hljs-string">'this'</span>), line, all);
    }
    <span class="hljs-keyword">return</span> Block(lines);
  },
  importAll: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[<span class="hljs-string">'import'</span>](it, <span class="hljs-literal">true</span>);
  },
  <span class="hljs-string">'const'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(lines)</span>{</span>
    <span class="hljs-keyword">var</span> i$, len$, node;
    <span class="hljs-keyword">for</span> (i$ = <span class="hljs-number">0</span>, len$ = lines.length; i$ &lt; len$; ++i$) {
      node = lines[i$];
      node.op === <span class="hljs-string">'='</span> || node.carp(<span class="hljs-string">'invalid constant variable declaration'</span>);
      node[<span class="hljs-string">'const'</span>] = <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">return</span> Block(lines);
  },
  <span class="hljs-string">'var'</span>: Vars
};
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Scope</span><span class="hljs-params">(parent, shared)</span>{</span>
  <span class="hljs-keyword">this</span>.parent = parent;
  <span class="hljs-keyword">this</span>.shared = shared;
  <span class="hljs-keyword">this</span>.variables = {};
}
ref$ = Scope.prototype;
ref$.READ_ONLY = {
  <span class="hljs-string">'const'</span>: <span class="hljs-string">'constant'</span>,
  <span class="hljs-string">'function'</span>: <span class="hljs-string">'function'</span>,
  <span class="hljs-literal">undefined</span>: <span class="hljs-string">'undeclared'</span>
};
ref$.add = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name, type, node)</span>{</span>
  <span class="hljs-keyword">var</span> t, that;
  <span class="hljs-keyword">if</span> (node &amp;&amp; (t = <span class="hljs-keyword">this</span>.variables[name + <span class="hljs-string">"."</span>])) {
    <span class="hljs-keyword">if</span> (that = <span class="hljs-keyword">this</span>.READ_ONLY[t] || <span class="hljs-keyword">this</span>.READ_ONLY[type]) {
      node.carp(<span class="hljs-string">"redeclaration of "</span> + that + <span class="hljs-string">" \""</span> + name + <span class="hljs-string">"\""</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t === type &amp;&amp; type === <span class="hljs-string">'arg'</span>) {
      node.carp(<span class="hljs-string">"duplicate parameter \""</span> + name + <span class="hljs-string">"\""</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t === <span class="hljs-string">'upvar'</span>) {
      node.carp(<span class="hljs-string">"accidental shadow of \""</span> + name + <span class="hljs-string">"\""</span>);
    }
    <span class="hljs-keyword">if</span> (t === <span class="hljs-string">'arg'</span> || t === <span class="hljs-string">'function'</span>) {
      <span class="hljs-keyword">return</span> name;
    }
  }
  <span class="hljs-keyword">this</span>.variables[name + <span class="hljs-string">"."</span>] = type;
  <span class="hljs-keyword">return</span> name;
};
ref$.get = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name)</span>{</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.variables[name + <span class="hljs-string">"."</span>];
};
ref$.declare = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name, node, constant)</span>{</span>
  <span class="hljs-keyword">var</span> that, scope;
  <span class="hljs-keyword">if</span> (that = <span class="hljs-keyword">this</span>.shared) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.check(name)) {
      <span class="hljs-keyword">return</span>;
    }
    scope = that;
  } <span class="hljs-keyword">else</span> {
    scope = <span class="hljs-keyword">this</span>;
  }
  <span class="hljs-keyword">return</span> scope.add(name, constant ? <span class="hljs-string">'const'</span> : <span class="hljs-string">'var'</span>, node);
};
ref$.assign = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name, value)</span>{</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.add(name, {
    value: value
  });
};
ref$.temporary = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name)</span>{</span>
  <span class="hljs-keyword">var</span> ref$;
  name || (name = <span class="hljs-string">'ref'</span>);
  <span class="hljs-keyword">while</span> ((ref$ = <span class="hljs-keyword">this</span>.variables[name + <span class="hljs-string">"$."</span>]) !== <span class="hljs-string">'reuse'</span> &amp;&amp; ref$ !== <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>) {
    name = name.length &lt; <span class="hljs-number">2</span> &amp;&amp; name &lt; <span class="hljs-string">'z'</span>
      ? <span class="hljs-built_in">String</span>.fromCharCode(name.charCodeAt() + <span class="hljs-number">1</span>)
      : name.replace(<span class="hljs-regexp">/\d*$/</span>, fn$);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.add(name + <span class="hljs-string">'$'</span>, <span class="hljs-string">'var'</span>);
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn$</span><span class="hljs-params">(it)</span>{</span>
    <span class="hljs-keyword">return</span> ++it;
  }
};
ref$.free = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name)</span>{</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.add(name, <span class="hljs-string">'reuse'</span>);
};
ref$.check = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name, above)</span>{</span>
  <span class="hljs-keyword">var</span> type, ref$;
  <span class="hljs-keyword">if</span> ((type = <span class="hljs-keyword">this</span>.variables[name + <span class="hljs-string">"."</span>]) || !above) {
    <span class="hljs-keyword">return</span> type;
  }
  <span class="hljs-keyword">return</span> (ref$ = <span class="hljs-keyword">this</span>.parent) != <span class="hljs-literal">null</span> ? ref$.check(name, above) : <span class="hljs-keyword">void</span> <span class="hljs-number">8</span>;
};
ref$.checkReadOnly = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name)</span>{</span>
  <span class="hljs-keyword">var</span> that, ref$, key$;
  <span class="hljs-keyword">if</span> (that = <span class="hljs-keyword">this</span>.READ_ONLY[<span class="hljs-keyword">this</span>.check(name, <span class="hljs-literal">true</span>)]) {
    <span class="hljs-keyword">return</span> that;
  }
  (ref$ = <span class="hljs-keyword">this</span>.variables)[key$ = name + <span class="hljs-string">"."</span>] || (ref$[key$] = <span class="hljs-string">'upvar'</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
};
ref$.emit = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(code, tab)</span>{</span>
  <span class="hljs-keyword">var</span> vrs, asn, fun, name, ref$, type, that, val;
  vrs = [];
  asn = [];
  fun = [];
  <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> ref$ = <span class="hljs-keyword">this</span>.variables) {
    type = ref$[name];
    name = name.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);
    <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'var'</span> || type === <span class="hljs-string">'const'</span> || type === <span class="hljs-string">'reuse'</span>) {
      vrs.push(name);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (that = type.value) {
      <span class="hljs-keyword">if</span> (~(val = entab(that, tab)).lastIndexOf(<span class="hljs-string">'function('</span>, <span class="hljs-number">0</span>)) {
        fun.push(<span class="hljs-string">"function "</span> + name + val.slice(<span class="hljs-number">8</span>));
      } <span class="hljs-keyword">else</span> {
        asn.push(name + <span class="hljs-string">" = "</span> + val);
      }
    }
  }
  <span class="hljs-keyword">if</span> (that = vrs.concat(asn).join(<span class="hljs-string">', '</span>)) {
    code = tab + <span class="hljs-string">"var "</span> + that + <span class="hljs-string">";\n"</span> + code;
  }
  <span class="hljs-keyword">if</span> (that = fun.join(<span class="hljs-string">"\n"</span> + tab)) {
    <span class="hljs-keyword">return</span> code + <span class="hljs-string">"\n"</span> + tab + that;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> code;
  }
};
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">YES</span><span class="hljs-params">()</span>{</span>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NO</span><span class="hljs-params">()</span>{</span>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">THIS</span><span class="hljs-params">()</span>{</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">VOID</span><span class="hljs-params">()</span>{</span>}
UTILS = {
  clone: <span class="hljs-string">'function(it){\n  function fun(){} fun.prototype = it;\n  return new fun;\n}'</span>,
  extend: <span class="hljs-string">'function(sub, sup){\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n  (sub.prototype = new fun).constructor = sub;\n  if (typeof sup.extended == \'function\') sup.extended(sub);\n  return sub;\n}'</span>,
  bind: <span class="hljs-string">'function(obj, key, target){\n  return function(){ return (target || obj)[key].apply(obj, arguments) };\n}'</span>,
  <span class="hljs-string">'import'</span>: <span class="hljs-string">'function(obj, src){\n  var own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n  return obj;\n}'</span>,
  importAll: <span class="hljs-string">'function(obj, src){\n  for (var key in src) obj[key] = src[key];\n  return obj;\n}'</span>,
  repeatString: <span class="hljs-string">'function(str, n){\n  for (var r = \'\'; n &gt; 0; (n &gt;&gt;= 1) &amp;&amp; (str += str)) if (n &amp; 1) r += str;\n  return r;\n}'</span>,
  repeatArray: <span class="hljs-string">'function(arr, n){\n  for (var r = []; n &gt; 0; (n &gt;&gt;= 1) &amp;&amp; (arr = arr.concat(arr)))\n    if (n &amp; 1) r.push.apply(r, arr);\n  return r;\n}'</span>,
  <span class="hljs-string">'in'</span>: <span class="hljs-string">'function(x, xs){\n  var i = -1, l = xs.length &gt;&gt;&gt; 0;\n  while (++i &lt; l) if (x === xs[i]) return true;\n  return false;\n}'</span>,
  out: <span class="hljs-string">'typeof exports != \'undefined\' &amp;&amp; exports || this'</span>,
  curry: <span class="hljs-string">'function(f, bound){\n  var context,\n  _curry = function(args) {\n    return f.length &gt; 1 ? function(){\n      var params = args ? args.concat() : [];\n      context = bound ? context || this : this;\n      return params.push.apply(params, arguments) &lt;\n          f.length &amp;&amp; arguments.length ?\n        _curry.call(context, params) : f.apply(context, params);\n    } : f;\n  };\n  return _curry();\n}'</span>,
  flip: <span class="hljs-string">'function(f){\n  return curry$(function (x, y) { return f(y, x); });\n}'</span>,
  partialize: <span class="hljs-string">'function(f, args, where){\n  var context = this;\n  return function(){\n    var params = slice$.call(arguments), i,\n        len = params.length, wlen = where.length,\n        ta = args ? args.concat() : [], tw = where ? where.concat() : [];\n    for(i = 0; i &lt; len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }\n    return len &lt; wlen &amp;&amp; len ?\n      partialize$.apply(context, [f, ta, tw]) : f.apply(context, ta);\n  };\n}'</span>,
  not: <span class="hljs-string">'function(x){ return !x; }'</span>,
  compose: <span class="hljs-string">'function() {\n  var functions = arguments;\n  return function() {\n    var i, result;\n    result = functions[0].apply(this, arguments);\n    for (i = 1; i &lt; functions.length; ++i) {\n      result = functions[i](result);\n    }\n    return result;\n  };\n}'</span>,
  deepEq: <span class="hljs-string">'function(x, y, type){\n  var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,\n      has = function (obj, key) { return hasOwnProperty.call(obj, key); };\n  var first = true;\n  return eq(x, y, []);\n  function eq(a, b, stack) {\n    var className, length, size, result, alength, blength, r, key, ref, sizeB;\n    if (a == null || b == null) { return a === b; }\n    if (a.__placeholder__ || b.__placeholder__) { return true; }\n    if (a === b) { return a !== 0 || 1 / a == 1 / b; }\n    className = toString.call(a);\n    if (toString.call(b) != className) { return false; }\n    switch (className) {\n      case \'[object String]\': return a == String(b);\n      case \'[object Number]\':\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case \'[object Date]\':\n      case \'[object Boolean]\':\n        return +a == +b;\n      case \'[object RegExp]\':\n        return a.source == b.source &amp;&amp;\n               a.global == b.global &amp;&amp;\n               a.multiline == b.multiline &amp;&amp;\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != \'object\' || typeof b != \'object\') { return false; }\n    length = stack.length;\n    while (length--) { if (stack[length] == a) { return true; } }\n    stack.push(a);\n    size = 0;\n    result = true;\n    if (className == \'[object Array]\') {\n      alength = a.length;\n      blength = b.length;\n      if (first) {\n        switch (type) {\n        case \'===\': result = alength === blength; break;\n        case \'&lt;==\': result = alength &lt;= blength; break;\n        case \'&lt;&lt;=\': result = alength &lt; blength; break;\n        }\n        size = alength;\n        first = false;\n      } else {\n        result = alength === blength;\n        size = alength;\n      }\n      if (result) {\n        while (size--) {\n          if (!(result = size in a == size in b &amp;&amp; eq(a[size], b[size], stack))){ break; }\n        }\n      }\n    } else {\n      if (\'constructor\' in a != \'constructor\' in b || a.constructor != b.constructor) {\n        return false;\n      }\n      for (key in a) {\n        if (has(a, key)) {\n          size++;\n          if (!(result = has(b, key) &amp;&amp; eq(a[key], b[key], stack))) { break; }\n        }\n      }\n      if (result) {\n        sizeB = 0;\n        for (key in b) {\n          if (has(b, key)) { ++sizeB; }\n        }\n        if (first) {\n          if (type === \'&lt;&lt;=\') {\n            result = size &lt; sizeB;\n          } else if (type === \'&lt;==\') {\n            result = size &lt;= sizeB\n          } else {\n            result = size === sizeB;\n          }\n        } else {\n          first = false;\n          result = size === sizeB;\n        }\n      }\n    }\n    stack.pop();\n    return result;\n  }\n}'</span>,
  split: <span class="hljs-string">"''.split"</span>,
  replace: <span class="hljs-string">"''.replace"</span>,
  toString: <span class="hljs-string">'{}.toString'</span>,
  join: <span class="hljs-string">'[].join'</span>,
  slice: <span class="hljs-string">'[].slice'</span>,
  splice: <span class="hljs-string">'[].splice'</span>
};
LEVEL_TOP = <span class="hljs-number">0</span>;
LEVEL_PAREN = <span class="hljs-number">1</span>;
LEVEL_LIST = <span class="hljs-number">2</span>;
LEVEL_COND = <span class="hljs-number">3</span>;
LEVEL_OP = <span class="hljs-number">4</span>;
LEVEL_CALL = <span class="hljs-number">5</span>;
(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
  <span class="hljs-keyword">this</span>[<span class="hljs-string">'&amp;&amp;'</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'||'</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'xor'</span>] = <span class="hljs-number">0.2</span>;
  <span class="hljs-keyword">this</span>[<span class="hljs-string">'.&amp;.'</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'.^.'</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'.|.'</span>] = <span class="hljs-number">0.3</span>;
  <span class="hljs-keyword">this</span>[<span class="hljs-string">'=='</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'!='</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'~='</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'!~='</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'==='</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'!=='</span>] = <span class="hljs-number">0.4</span>;
  <span class="hljs-keyword">this</span>[<span class="hljs-string">'&lt;'</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'&gt;'</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'&lt;='</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'&gt;='</span>] = <span class="hljs-keyword">this</span>.of = <span class="hljs-keyword">this</span>[<span class="hljs-string">'instanceof'</span>] = <span class="hljs-number">0.5</span>;
  <span class="hljs-keyword">this</span>[<span class="hljs-string">'&lt;&lt;='</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'&gt;&gt;='</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'&lt;=='</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'&gt;=='</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'++'</span>] = <span class="hljs-number">0.5</span>;
  <span class="hljs-keyword">this</span>[<span class="hljs-string">'.&lt;&lt;.'</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'.&gt;&gt;.'</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'.&gt;&gt;&gt;.'</span>] = <span class="hljs-number">0.6</span>;
  <span class="hljs-keyword">this</span>[<span class="hljs-string">'+'</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'-'</span>] = <span class="hljs-number">0.7</span>;
  <span class="hljs-keyword">this</span>[<span class="hljs-string">'*'</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'/'</span>] = <span class="hljs-keyword">this</span>[<span class="hljs-string">'%'</span>] = <span class="hljs-number">0.8</span>;
}.call(PREC = {
  unary: <span class="hljs-number">0.9</span>
}));
TAB = <span class="hljs-string">'  '</span>;
ID = <span class="hljs-regexp">/^(?!\d)[\w$\xAA-\uFFDC]+$/</span>;
SIMPLENUM = <span class="hljs-regexp">/^\d+$/</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">util</span><span class="hljs-params">(it)</span>{</span>
  <span class="hljs-keyword">return</span> Scope.root.assign(it + <span class="hljs-string">'$'</span>, UTILS[it]);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">entab</span><span class="hljs-params">(code, tab)</span>{</span>
  <span class="hljs-keyword">return</span> code.replace(<span class="hljs-regexp">/\n/g</span>, <span class="hljs-string">'\n'</span> + tab);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">import$</span><span class="hljs-params">(obj, src)</span>{</span>
  <span class="hljs-keyword">var</span> own = {}.hasOwnProperty;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> src) <span class="hljs-keyword">if</span> (own.call(src, key)) obj[key] = src[key];
  <span class="hljs-keyword">return</span> obj;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clone$</span><span class="hljs-params">(it)</span>{</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span>{</span>} fun.prototype = it;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> fun;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extend$</span><span class="hljs-params">(sub, sup)</span>{</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span>{</span>} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = <span class="hljs-keyword">new</span> fun).constructor = sub;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> sup.extended == <span class="hljs-string">'function'</span>) sup.extended(sub);
  <span class="hljs-keyword">return</span> sub;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">in$</span><span class="hljs-params">(x, xs)</span>{</span>
  <span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>, l = xs.length &gt;&gt;&gt; <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (++i &lt; l) <span class="hljs-keyword">if</span> (x === xs[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">repeatString$</span><span class="hljs-params">(str, n)</span>{</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> r = <span class="hljs-string">''</span>; n &gt; <span class="hljs-number">0</span>; (n &gt;&gt;= <span class="hljs-number">1</span>) &amp;&amp; (str += str)) <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) r += str;
  <span class="hljs-keyword">return</span> r;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">importAll$</span><span class="hljs-params">(obj, src)</span>{</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> src) obj[key] = src[key];
  <span class="hljs-keyword">return</span> obj;
}</div></div></div></div></body></html>