{
  "name": "feathers",
  "description": "An ultra scalable, feather weight, data oriented framework",
  "version": "0.3.2",
  "homepage": "http://feathersjs.com",
  "repository": {
    "type": "git",
    "url": "git://github.com/feathersjs/feathers.git"
  },
  "keywords": [
    "feathers",
    "REST",
    "socket.io",
    "realtime"
  ],
  "author": {
    "name": "Feathers",
    "email": "hello@feathersjs.com",
    "url": "http://feathersjs.com"
  },
  "contributors": [
    {
      "name": "Eric Kryski",
      "email": "e.kryski@gmail.com",
      "url": "http://erickryski.com"
    },
    {
      "name": "David Luecke",
      "email": "daff@neyeon.de",
      "url": "http://neyeon.com"
    }
  ],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/feathersjs/feathers/issues"
  },
  "main": "lib/feathers",
  "directories": {
    "lib": "lib"
  },
  "scripts": {
    "test": "grunt"
  },
  "engines": {
    "node": "*",
    "npm": "*"
  },
  "dependencies": {
    "uberproto": "~1.x",
    "express": "~3.4.0",
    "rubberduck": "~1.x",
    "socket.io": "~0.9.0",
    "primus-emitter": "~3.x",
    "primus": "~2.x",
    "lodash": "~2.4.1"
  },
  "devDependencies": {
    "request": "~2.x",
    "socket.io-client": "~0.9.0",
    "grunt-cli": "~0.1.0",
    "grunt": "~0.4.0",
    "grunt-release": "~0.5.0",
    "mocha": "~1.x",
    "grunt-contrib-jshint": "~0.x",
    "grunt-simple-mocha": "~0.4.0",
    "grunt-jsbeautifier": "~0.2.0"
  },
  "readme": "## Introduction\n\nFeathers is a light weight web application framework that rides on top of [Express](http://expressjs.com), one of the most popular web frameworks for [NodeJS](http://nodejs.org/). It makes it easy to create RESTful web services and real-time applications using SocketIO and several other NodeJS real-time libraries.\n\nIf you are not familiar with Express head over to the [Express Guides](http://expressjs.com/guide.html) to get an idea. Feathers works the exact same way except that `var app = require('express')();` is replaced with `var app = require('feathers')()`. The most important concept that Feathers adds to Express middleware is data oriented **Services**. How services work and the API additional to the available [Express API](http://expressjs.com/api.html) is outlined in the following documentation.\n\n## Configuration\n\n### REST\n\nExposing services through a RESTful JSON interface is enabled by default. If you only want to use SocketIO call `app.disabled('feathers rest')` _before_ registering any services.\n\nTo set service parameters in a middleware, just attach it to the `req.feathers` object which will become the params for any resulting service call:\n\n```js\napp.use(function(req, res) {\n  req.feathers.data = 'Hello world';\n});\n\napp.use('/todos', {\n  get: function(name, params, callback) {\n    console.log(params.data); // -> 'Hello world'\n    callback(null, {\n      id: name,\n      params: params,\n      description: \"You have to do \" + name + \"!\"\n    });\n  }\n});\n```\n\n### SocketIO\n\nTo expose services via [SocketIO](http://socket.io/) call `app.configure(feathers.socketio())`. It is also possible pass a `function(io) {}` when initializing the provider where `io` is the main SocketIO object. Since Feathers is only using the SocketIO default configuration, this is a good spot to initialize the [recommended production settings](https://github.com/LearnBoost/Socket.IO/wiki/Configuring-Socket.IO#recommended-production-settings):\n\n```js\napp.configure(feathers.socketio(function(io) {\n  io.enable('browser client minification');  // send minified client\n  io.enable('browser client etag');          // apply etag caching logic based on version number\n  io.enable('browser client gzip');          // gzip the file\n  io.set('log level', 1);                    // reduce logging\n\n  // enable all transports (optional if you want flashsocket support, please note that some hosting\n  // providers do not allow you to create servers that listen on a port different than 80 or their\n  // default port)\n  io.set('transports', [\n      'websocket'\n    , 'flashsocket'\n    , 'htmlfile'\n    , 'xhr-polling'\n    , 'jsonp-polling'\n  ]);\n}));\n```\n\nThis is also the place to listen to custom events or add [authorization](https://github.com/LearnBoost/socket.io/wiki/Authorizing):\n\n```js\napp.configure(feathers.socketio(function(io) {\n  io.on('connection', function(socket) {\n    socket.emit('news', { hello: 'world' });\n    socket.on('my other event', function (data) {\n      console.log(data);\n    });\n  });\n\n  io.set('authorization', function (handshakeData, callback) {\n    // Authorize using the /users service\n    app.lookup('users').find({\n      username: handshakeData.username,\n      password: handshakeData.password\n    }, callback);\n  });\n}));\n```\n\nOnce the server has been started with `app.listen()` the SocketIO object is available as `app.io`.\n\n### Primus\n\n[Primus](https://github.com/primus/primus) is a universal wrapper for real-time frameworks and allows you to transparently use Engine.IO, WebSockets, BrowserChannel, SockJS and Socket.IO. Set it up with `feathers.primus(configuration [, fn])` where `configuration` is the [Primus server configuration](https://github.com/primus/primus#getting-started) and `fn` an optional callback with the Primus server instance that can e.g. be used for setting up [authorization](https://github.com/primus/primus#authorization):\n\n```js\n// Set up Primus with SockJS\napp.configure(feathers.primus({\n  transformer: 'sockjs'\n}, function(primus) {\n  // Set up Primus authorization here\n  primus.authorize(function (req, done) {\n    var auth;\n\n    try { auth = authParser(req.headers['authorization']) }\n    catch (ex) { return done(ex) }\n\n    // Do some async auth check\n    authCheck(auth, done);\n  });\n}));\n```\n\nIn the Browser you can connect like this:\n\n```html\n<script type=\"text/javascript\" src=\"primus/primus.js\"></script>\n<script type=\"text/javascript\">\n  var primus = new Primus(url);\n\n  primus.on('todos created', function(todo) {\n    console.log('Someone created a Todo', todo);\n  });\n\n  primus.send('todos::create', { description: 'Do something' }, {}, function() {\n    primus.send('todos::find', {}, function(error, todos) {\n      console.log(todos);\n    });\n  });\n</script>\n```\n\n## API\n\n### listen\n\n`app.listen([port])` starts the application on the given port. It will first call the original [Express app.listen([port])](http://expressjs.com/api.html#app.listen), then run `app.setup(server)` (see below) with the server object and then return the server object.\n\n### setup\n\n`app.setup(server)` is used initialize all services by calling each services `.setup(app, path)` method (if available).\nIt will also use the `server` instance passed (e.g. through `http.createServer`) to set up SocketIO (if enabled) and any other provider that might require the server instance.\n\nNormally `app.setup` will be called automatically when starting the application via `app.listen([port])` but there are cases when you need to initialize the server separately:\n\n__HTTPS__\n\nWith your Feathers application initialized it is easy to set up an HTTPS REST and SocketIO server:\n\n```js\napp.configure(feathers.socketio()).use('/todos', todoService);\n\nvar https = require('https');\nvar server = https.createServer({\n  key: fs.readFileSync('privatekey.pem'),\n  cert: fs.readFileSync('certificate.pem')\n}, app).listen(443);\n\n// Call app.setup to initialize all services and SocketIO\napp.setup(server);\n```\n\n__Virtual Hosts__\n\nYou can use `feathers.vhost` (which is the same as [Express and Connect .vhost](http://www.senchalabs.org/connect/vhost.html)) to run your Feathers app on a virtual host:\n\n```js\napp.use('/todos', todoService);\n\nvar host = feathers().use(feathers.vhost('foo.com', app));\nvar server = host.listen(8080);\n\n// Here we need to call app.setup because .listen on our virtal hosted\n// app is never called\napp.setup(server);\n```\n\n### lookup\n\n`app.lookup(path)` returns the wrapped service object for the given path. Note that Feathers internally creates a new object from each registered service. This means that the object returned by `lookup` will provide the same methods and functionality as the original service but also functionality added by Feathers (most notably it is possible to listen to service events). `path` can be the service name with or without leading and trailing slashes.\n\n```js\napp.use('/my/todos', {\n  create: function(data, params, callback) {\n    callback(null, data);\n  }\n});\n\nvar todoService = app.lookup('my/todos');\n// todoService is an event emitter\ntodoService.on('created', function(todo) {\n  console.log('Created todo', todo);\n});\n```\n\n### use\n\n`app.use([path], service)` works just like [Express app.use([path], middleware)](http://expressjs.com/api.html#app.use) but additionally allows to register a service object (an object which at least provides one of the service methods as outlined in the Services section) instead of the middleware function. Note that REST services are registered in the same order as any other middleware so the below example will allow the `/todos` service only to [Passport](http://passportjs.org/) authenticated users.\n\n```js\n// Serve public folder for everybody\napp.use(feathers.static(__dirname + '/public');\n// Make sure that everything else only works with authentication\napp.use(function(req,res,next){\n  if(req.isAuthenticated()){\n    next();\n  } else {\n    // 401 Not Authorized\n    next(new Error(401));\n  }\n});\n// Add a service.\napp.use('/todos', {\n  get: function(name, params, callback) {\n    callback(null, {\n      id: name,\n      description: \"You have to do \" + name + \"!\"\n    });\n  }\n});\n```\n\n### service\n\n`app.service([path], service)` is what is called internally by `app.use([path], service)` if a service object is being passed. Use it instead of `app.use([path], service)` if you want to be more explicit that you are registering a service. `app.service` does __not__ provide the Express `app.use` functionality and doesn't check the service object for valid methods.\n\n## Services\n\nA service can be any JavaScript object that offers one or more of the `find`, `get`, `create`, `update`, `remove` and `setup` service methods with the following signatures:\n\n```js\nvar myService = {\n  find: function(params, callback) {},\n  get: function(id, params, callback) {},\n  create: function(data, params, callback) {},\n  update: function(id, data, params, callback) {},\n  remove: function(id, params, callback) {},\n  setup: function(app) {}\n}\n```\n\nAll callbacks follow the `function(error, data)` NodeJS convention. `params` can contain any additional parameters, for example the currently authenticated user. REST service calls set `params.query` with the query parameters (e.g. a query string like `?status=active&type=user` becomes `{ query: { status: \"active\", type: \"user\" } }`).\n\n### find\n\n`find(params, callback)` retrieves a list of all resources from the service. Ideally use `params.query` for things like filtering and paging so that REST calls like `todo?status=completed&user=10` work right out of the box.\n\n__REST__\n\n    GET todo?status=completed&user=10\n\n__SocketIO__\n\n```js\nsocket.emit('todo::find', {\n  query: {\n    status: 'completed'\n    user: 10\n  }\n}, function(error, data) {\n});\n```\n\n### get\n\n`get(id, params, callback)` retrieves a single resource with the given `id` from the service.\n\n__REST__\n\n    GET todo/1\n\n__SocketIO__\n\n```js\nsocket.emit('todo::get', 1, {}, function(error, data) {\n\n});\n```\n\n### create\n\n`create(data, params, callback)` creates a new resource with `data`. The callback should be called with the newly\ncreated resource data.\n\n__REST__\n\n    POST todo\n    { \"description\": \"I really have to iron\" }\n\nBy default the body can be eihter JSON or form encoded as long as the content type is set accordingly.\n\n__SocketIO__\n\n```js\nsocket.emit('todo::create', {\n  description: 'I really have to iron'\n}, {}, function(error, data) {\n});\n```\n\n### update\n\n`update(id, data, params, callback)` updates the resource identified by `id` using `data`. The callback should\nbe called with the updated resource data.\n\n__REST__\n\n    PUT todo/2\n    { \"description\": \"I really have to do laundry\" }\n\n__SocketIO__\n\n```js\nsocket.emit('todo::update', 2, {\n  description: 'I really have to do laundry'\n}, {}, function(error, data) {\n  // data -> { id: 2, description: \"I really have to do laundry\" }\n});\n```\n\n### remove\n\n`remove(id, params, callback)` removes the resource with `id`. The callback should be called with the removed resource.\n\n__REST__\n\n    DELETE todo/2\n\n__SocketIO__\n\n```js\nsocket.emit('todo::remove', 2, {}, function(error, data) {\n});\n```\n\n### setup\n\n`setup(app, path)` initializes the service passing an instance of the Feathers application and the path it has been registered on. The SocketIO server is available via `app.io`. `setup` is a great way to connect services:\n\n```js\nvar todoService = {\n  get: function(name, params, callback) {\n    callback(null, {\n      id: name,\n      description: 'You have to ' + name + '!'\n    });\n  }\n};\n\nvar myService = {\n  setup: function(app) {\n    this.todo = app.lookup('todo');\n  },\n\n  get: function(name, params, callback) {\n    this.todo.get('take out trash', {}, function(error, todo) {\n      callback(error, {\n        name: name,\n        todo: todo\n      });\n    });\n  }\n}\n\nfeathers()\n\t.use('todo', todoService)\n\t.use('my', myService)\n\t.listen(8000);\n```\n\nYou can see the combination when going to `http://localhost:8000/my/test`.\n\n__Pro tip:__\n\nBind the apps `lookup` method to your service to always look your services up dynamically:\n\n```\nvar myService = {\n  setup: function(app) {\n    this.lookup = app.lookup.bind(app);\n  },\n\n  get: function(name, params, callback) {\n    this.lookup('todos').get('take out trash', {}, function(error, todo) {\n      callback(null, {\n        name: name,\n        todo: todo\n      });\n    });\n  }\n}\n```\n\n## Events\n\nAny registered service will be automatically turned into an event emitter that emits events when a resource has changed, that is a `create`, `update` or `remove` service call returned successfully. It is therefore possible to bind to the below events via `app.lookup(servicename).on()` and, if enabled, all events will also broadcast to all connected SocketIO clients in the form of `<servicepath> <eventname>`. Note that the service path will always be stripped of leading and trailing slashes regardless of how it has been registered (e.g. `/my/service/` will become `my/service`).\n\n### created\n\nThe `created` event will be published with the callback data when a service `create` calls back successfully.\n\n```js\napp.use('/todos', {\n  create: function(data, params, callback) {\n    callback(null, data);\n  }\n});\n\napp.lookup('/todos').on('created', function(todo) {\n  console.log('Created todo', todo);\n});\n\napp.lookup('/todos').create({\n  description: 'We have to do something!'\n}, {}, function(error, callback) {\n  // ...\n});\n\napp.listen(8000);\n```\n\n__SocketIO__\n\n```html\n<script src=\"http://localhost:8000/socket.io/socket.io.js\"></script>\n<script>\n  var socket = io.connect('http://localhost:8000/');\n\n  socket.on('todos created', function(todo) {\n    console.log('Got a new Todo!', todo);\n  });\n</script>\n```\n\n### updated\n\nThe `updated` event will be published with the callback data when a service `update` calls back successfully.\n\n```js\napp.use('/my/todos/', {\n  update: function(id, data, params, callback) {\n    callback(null, data);\n  }\n});\n\napp.listen(8000);\n```\n\n__SocketIO__\n\n```html\n<script src=\"http://localhost:8000/socket.io/socket.io.js\"></script>\n<script>\n  var socket = io.connect('http://localhost:8000/');\n\n  socket.on('my/todos updated', function(todo) {\n    console.log('Got an updated Todo!', todo);\n  });\n\n  socket.emit('my/todos::update', 1, {\n    description: 'Updated description'\n  }, {}, function(error, callback) {\n   // Do something here\n  });\n</script>\n```\n\n### removed\n\nThe `removed` event will be published with the callback data when a service `remove` calls back successfully.\n\n```js\napp.use('/todos', {\n  remove: function(id, params, callback) {\n    callback(null, { id: id });\n  }\n});\n\napp.lookup('/todos').remove(1, {}, function(error, callback) {\n  // ...\n});\n\napp.listen(8000);\n```\n\n__SocketIO__\n\n```html\n<script src=\"http://localhost:8000/socket.io/socket.io.js\"></script>\n<script>\n  var socket = io.connect('http://localhost:8000/');\n\n  socket.on('todos removed', function(todo) {\n    // Remove element showing the Todo from the page\n    $('#todo-' + todo.id).remove();\n  });\n</script>\n```\n\n## Why?\n\nWe know! Oh God another NodeJS framework! We really didn't want to add another name to the long list of NodeJS web frameworks but also wanted to explore a different approach than any other framework we have seen. We strongly believe that data is the core of the web and should be the focus of web applications.\n\nWe also think that your data resources can and should be encapsulated in such a way that they can be scalable, easily testable and self contained. The classic web MVC pattern used to work well but is becoming antiquated in today's web.\n\nWith that being said there are some amazing frameworks already out there and we wanted to leverage the ideas that have been put into them, which is why Feathers is built on top of [Express](http://expressjs.com) and is inspired in part by [Sails](http://sailsjs.org), [Flatiron](http://flatironjs.org) and [Derby](http://derbyjs.com).\n\n## Changelog\n\n__0.3.2__\n\n- Allows Feathers to use other Express apps ([#46](https://github.com/feathersjs/feathers/pull/46))\n- Updated dependencies and switched to Lodash ([#42](https://github.com/feathersjs/feathers/pull/42))\n\n__0.3.1__\n\n- REST provider refactoring ([#35](https://github.com/feathersjs/feathers/pull/35)) to make it easier to develop plugins\n- HTTP requests now return 405 (Method not allowed) when trying to access unavailable service methods ([#35](https://github.com/feathersjs/feathers/pull/35))\n\n__0.3.0__\n\n- Added [Primus](https://github.com/primus/primus) provider ([#34](https://github.com/feathersjs/feathers/pull/34))\n- `app.setup(server)` to support HTTPS (and other functionality that requires a custom server) ([#33](https://github.com/feathersjs/feathers/pull/33))\n- Removed bad SocketIO configuration ([#19](https://github.com/feathersjs/feathers/issues/19))\n- Add .npmignore to not publish .idea folder ([#30](https://github.com/feathersjs/feathers/issues/30))\n- Remove middleware: connect.bodyParser() ([#27](https://github.com/feathersjs/feathers/pull/27))\n\n__0.2.0__\n\n- Pre-initialize `req.feathers` in REST provider to set service parameters\n- Allowing to initialize services with or without slashes to be more express-compatible\n\n__0.1.0__\n\n- First beta release\n- Directly extends Express\n- Removed built in services and moved to [Legs](https://github.com/feathersjs/legs)\n- Created [example repository](https://github.com/feathersjs/examples)\n\n__0.0.x__\n\n- Initial test alpha releases\n\n## License\n\nCopyright (C) 2013 David Luecke daff@neyeon.com\nCopyright (C) 2013 Eric Kryski e.kryski@gmail.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n",
  "readmeFilename": "readme.md",
  "_id": "feathers@0.3.2",
  "_from": "feathers@~0.3.0"
}
